<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>VAPI Integrated App</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Hide the Vapi call button injected from the CDN */
      #vapi-icon-container,
      #vapi-support-btn {
        display: none !important;
      }
      /* Survey section styling */
      #survey-section textarea {
        margin-bottom: 10px;
      }
      /* Updated survey-response styling */
#survey-response {
  width: 100%;
  max-height: 500px; /* Prevent container from growing too tall */
  overflow-y: auto;  /* Add vertical scrollbar if content overflows */
  background-color: #fff;
  padding: 1.5rem;
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  margin-bottom: 1.5rem; /* Extra space to avoid overlapping with call section */
}
/* Styling for multiple-choice options */
/* Multiple-choice option container */
/* Container for each radio button + label pair */
.mcq-option {
  display: flex;               /* Put the radio button + label in a row */
  align-items: center;         /* Vertically center them */
  justify-content: flex-start; /* Keep them on the left side */
  margin-bottom: 0.5rem;       /* Spacing between each option */
  width: auto;                 /* Don’t force 100% width for each option */
}

/* Radio input spacing */
.mcq-option input[type="radio"] {
  margin-right: 0.5rem;
  width: auto; 
}

/* Ensure labels don’t take up 100% width */
.mcq-option label {
  width: auto;
  display: inline-block; 
}



      select,
      textarea,
      input {
        background-color: #fffdfb;
        border: 1px solid #e5e7eb;
        border-radius: 4px;
        width: 100%;
        padding: 8px 12px;
        color: #374151;
      }
      select {
        appearance: none;
        background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
        background-position: right 0.5rem center;
        background-repeat: no-repeat;
        background-size: 1.5em 1.5em;
        padding-right: 2.5rem;
      }
      textarea:focus,
      select:focus {
        outline: none;
        border-color: #e5e7eb;
        box-shadow: 0 0 0 1px #e5e7eb;
      }
      .volume-bar {
        width: 4px;
        height: 30px;
        background-color: #d1d5db;
      }
      .volume-bar.active {
        background-color: #3b82f6;
      }
    </style>
  </head>
  <body class="bg-[#F6F6F6]">
    <div class="flex min-h-screen">
      <!-- Sidebar -->
      <aside
        class="w-16 bg-[#210803] text-white flex flex-col items-center p-4"
      >
        <!-- History Icon -->
        <a
          href="/history"
          class="mt-8 mb-4 hover:text-gray-400 text-2xl text-center"
          title="View History"
        >
          <img
            src="{{ url_for('static', filename='images/history.png') }}"
            alt="History Icon"
            class="w-8 h-8 transform translate-x-2"
          />
          <span class="text-sm mt-2 block font-bold">History</span>
        </a>
        <!-- Analysis Icon -->
        <a
          href="/analysis"
          class="mb-4 hover:text-gray-400 text-2xl text-center"
          title="View Analysis"
        >
          <img
            src="{{ url_for('static', filename='images/graph.png') }}"
            alt="Analysis Icon"
            class="w-8 h-8 transform translate-x-2"
          />
          <span class="text-sm mt-2 block font-bold">Analysis</span>
        </a>
        <!-- New Public Survey Link element -->
<a id="public-survey-link" href="#" class="mt-2 text-xs hover:text-gray-400 text-center" title="Public Survey Link">
  Public Survey Link
</a>

      </aside>
      <!-- Main Container -->
      <div class="flex-1">
        <div class="max-w-7xl mx-auto px-4 py-6 grid grid-cols-4 gap-6">
          <!-- Survey Prompt Section -->
          <div class="bg-white p-6 rounded-lg shadow-sm space-y-6 h-full">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">
              Create a Survey Prompt
            </h2>
            <!-- Prompt Input -->
            <div class="mb-4">
              <label class="block text-sm text-gray-600 mb-1"
                >Enter Prompt:</label
              >
              <textarea
                  id="survey-prompt"
                  rows="4"
                  placeholder="Enter your survey prompt here..."
                  class="w-full border  text-sm border-gray-300 rounded-xl px-3 py-2"
                ></textarea>

             
            </div>
            <!-- Dropdowns -->
            <div class="grid grid-cols-2 gap-4 mb-4">
              <div>
                <label class="block text-sm text-gray-600 mb-1">Accent:</label>
                <select
                  id="accent"
                  class="w-full text-sm border border-gray-300 rounded-xl px-3 py-2"
                >
                  <option value="indian_lady">Indian Lady</option>
                  <option value="indian_man">Indian Man</option>
                  <option value="british_lady">British Female</option>
                  <option value="british_man">British Man</option>
                  <option value="anime_girl">Anime Girl</option>
                  <option value="middle_east_women">
                    Middle Eastern Women
                  </option>
                  <option value="australian_women">Australian Women</option>
                  <option value="california_girl">California Girl</option>
                  <option value="new_york_man">New York Man</option>
                  <option value="new_york_women">New York Women</option>
                  <option value="savannah">American Southern Accent</option>
                  <option value="kentucky_man">Kentucky Man</option>
                  <option value="kentucky_woman">Kentucky Woman</option>
                </select>
              </div>
              <div>
                <label class="block text-sm text-gray-600 mb-1"
                  >Survey Length:</label
                >
                <select
                  id="survey-length"
                  class="w-full text-sm border border-gray-300 rounded-xl px-3 py-2"
                >
                  <option value="short">Short (2 mins)</option>
                  <option value="medium">Medium (3-5 mins)</option>
                  <option value="long">Long (5+ mins)</option>
                </select>
              </div>
            </div>
            <div class="grid grid-cols-2 gap-4 mb-4">
              <div>
                <label class="block text-sm text-gray-600 mb-1">Tone:</label>
                <select
                  id="tone"
                  class="w-full text-sm border border-gray-300 rounded-xl px-3 py-2"
                >
                  <option value="neutral">Neutral</option>
                  <option value="friendly">Friendly</option>
                  <option value="professional">Professional</option>
                </select>
              </div>
              <div>
                <label class="block text-sm text-gray-600 mb-1">Extras:</label>
                <select
                  id="extras"
                  class="w-full text-sm border border-gray-300 rounded-xl px-3 py-2"
                >
                  <option value="none">None</option>
                  <option value="anger">Anger</option>
                  <option value="positivity">Positivity</option>
                  <option value="surprise">Surprise</option>
                  <option value="sadness">Sadness</option>
                  <option value="curiosity">Curiosity</option>
                </select>
              </div>
            </div>
            <!-- Survey Submission Button -->
            <div class="flex space-x-4 mt-4">
              <button
                id="survey-submit-btn"
                class="bg-[#FF714C] hover:bg-[#f2613c] text-white py-2 px-4 rounded-full transition-colors font-bold"
              >
                Submit Survey Prompt
              </button>
            </div>
            <!-- Integrated PDF Upload -->
            <div id="pdf-upload-section" class="mt-6 border-t pt-6">
              <h3 class="text-xl font-semibold text-gray-700">Or Upload PDF</h3>
              <div class="flex items-center gap-4">
                <input
                  type="file"
                  id="pdf-file"
                  accept="application/pdf"
                  class="flex-1 px-3 py-2 text-sm text-gray-700"
                />
                <button
                  id="upload-btn"
                  class="bg-[#FF714C] text-white py-2 px-4 rounded-full hover:bg-[#f2613c] transition-colors font-bold"
                >
                  Extract
                </button>
              </div>
              <p id="upload-status" class="text-sm text-gray-600 mt-2"></p>
            </div>
          </div>
          <!-- Main Content Area (Survey Response) -->
          <div class="col-span-3 h-screen flex flex-col p-6 pt-0">
            <div class="flex-1 flex flex-col ">
              <label
                class="mb-2 text-sm font-medium text-gray-700"
                for="survey-response"
              >
                Response:
              </label>
              <div id="survey-response" class=" flex-1 bg-white p-6 rounded-lg shadow-md mb-0"></div>
            </div>
            <!-- Buttons for Voice AI and Chat with Survey -->
            <div class="flex space-x-4 mt-4 self-end">
              <button
                id="send-voice-btn"
                class="bg-[#FF714C] hover:bg-[#f2613c] text-white py-2 px-4 rounded-md transition-colors font-semibold"
              >
                Send to Voice AI
              </button>
              <button
                id="chat-survey-btn"
                class="bg-green-500 hover:bg-green-600 text-white py-2 px-4 rounded-md transition-colors font-semibold "
              >
                Chat with Survey
              </button>
            </div>
          </div>
        </div>
        <!-- Call Section -->
        <!-- Call Section -->
<div id="call-section" class="w-full max-w-3xl mx-auto my-8 p-6 bg-white rounded-lg shadow-lg">
  <!-- New heading element for survey heading -->
  <h2 id="call-heading" class="text-xl font-semibold text-gray-700 mb-4">Call in Progress</h2>
  <p id="assistant-status" class="text-sm text-gray-600 mb-4">Assistant Status: Not Speaking</p>
  <div id="volume-level" class="flex space-x-2 mb-4"></div>
  <button id="stop-btn" class="bg-red-500 text-white py-1 px-3 rounded-md hover:bg-red-600 transition-colors">
    Stop Call
  </button>
  <div id="call-summary" class="mt-4 text-sm text-gray-600"></div>
</div>

        <!-- Chat Container (hidden by default) -->
        <!-- Chat Container (hidden by default) -->
<div id="chat-container" class="hidden max-w-3xl mx-auto my-8 p-6 bg-white rounded-lg shadow-lg">
  <!-- New heading element for survey heading in chat -->
  <h2 id="chat-heading" class="text-xl font-semibold text-gray-700 mb-4">Chat Interface</h2>
  <div id="chat-messages" class="mb-4 overflow-auto max-h-64">
    <!-- Initial message will be inserted here -->
  </div>
  <div class="flex space-x-4">
    <input type="text" id="chat-input" class="flex-1 p-2 border rounded-md" placeholder="Type your question..." />
    <button id="chat-send-btn" class="bg-green-500 hover:bg-green-600 text-white font-semibold rounded-md px-4 py-2 transition-colors">
      Send
    </button>
  </div>
  <div class="mt-4 flex justify-between items-center">
    <a href="#" id="back-to-voice" class="text-blue-500 hover:underline">Back to Voice AI</a>
    <!-- New Stop Survey button -->
    <button id="stop-survey-btn" class="bg-red-500 hover:bg-red-600 text-white font-semibold rounded-md px-4 py-2 transition-colors">
      Stop Survey
    </button>
  </div>
</div>

      </div>
    </div>

    <!-- VAPI SDK Script -->
    <script>
      var vapiInstance = null;
      const assistant = "5e7d3a07-f7d5-4975-8bd8-2c32ae092f01";
      const apiKey = "c2e5d26a-941f-42c7-8bf4-02ebc2844242";

      (function (d, t) {
        var g = document.createElement(t),
          s = d.getElementsByTagName(t)[0];
        g.src =
          "https://cdn.jsdelivr.net/gh/VapiAI/html-script-tag@latest/dist/assets/index.js";
        g.defer = true;
        g.async = true;
        s.parentNode.insertBefore(g, s);

        g.onload = function () {
          vapiInstance = window.vapiSDK.run({
            apiKey: apiKey,
            assistant: assistant,
          });

          vapiInstance.on("speech-start", () => {
            document.getElementById("assistant-status").textContent =
              "Assistant Status: Speaking";
          });
          vapiInstance.on("speech-end", () => {
            document.getElementById("assistant-status").textContent =
              "Assistant Status: Not Speaking";
          });
          vapiInstance.on("volume-level", (level) => {
            const volumeEl = document.getElementById("volume-level");
            volumeEl.innerHTML = "";
            const numBars = 10;
            for (let i = 0; i < numBars; i++) {
              let bar = document.createElement("div");
              bar.className =
                "volume-bar" + (i / numBars < level ? " active" : "");
              volumeEl.appendChild(bar);
            }
          });
        };
      })(document, "script");

      let globalCallId = null;
      // Use separate variables for history record and chat record IDs.
      window.latestRecordId = null;
      window.latestChatRecordId = null;
      window.latestRawTranscript = null;

      //       if (!window.chatRecordCounter) {
      //   window.chatRecordCounter = 1;
      // }
      if (!localStorage.getItem("chatRecordCounter")) {
        localStorage.setItem("chatRecordCounter", "1");
      }

      // Start the assistant call using the Web SDK
      function startWebCall(extractedText) {
        const accentValue = document.getElementById("accent").value;
        const extrasValue = document.getElementById("extras").value;
        const toneValue = document.getElementById("tone").value;
        let voiceConfig = {};
        switch (accentValue) {
          case "indian_lady":
            voiceConfig = {
              provider: "cartesia",
              voiceId: "3b554273-4299-48b9-9aaf-eefd438e3941",
            };
            break;
          case "indian_man":
            voiceConfig = {
              provider: "cartesia",
              voiceId: "638efaaa-4d0c-442e-b701-3fae16aad012",
            };
            break;
          case "british_lady":
            voiceConfig = {
              provider: "cartesia",
              voiceId: "79a125e8-cd45-4c13-8a67-188112f4dd22",
            };
            break;
          case "anime_girl":
            voiceConfig = {
              provider: "cartesia",
              voiceId: "1001d611-b1a8-46bd-a5ca-551b23505334",
            };
            break;
          case "british_man":
            voiceConfig = {
              provider: "cartesia",
              voiceId: "63ff761f-c1e8-414b-b969-d1833d1c870c",
            };
            break;
          case "middle_east_women":
            voiceConfig = {
              provider: "cartesia",
              voiceId: "daf747c6-6bc2-4083-bd59-aa94dce23f5d",
            };
            break;
          case "australian_women":
            voiceConfig = {
              provider: "cartesia",
              voiceId: "043cfc81-d69f-4bee-ae1e-7862cb358650",
            };
            break;
          case "california_girl":
            voiceConfig = { provider: "cartesia", voiceId: "b7d50908-b17c-442d-ad8d-810c63997ed9" };
            break;
          case "new_york_man":
            voiceConfig = { provider: "cartesia", voiceId: "34575e71-908f-4ab6-ab54-b08c95d6597d" };
            break;
          case "new_york_women":
            voiceConfig = { provider: "cartesia", voiceId: "34bde396-9fde-4ebf-ad03-e3a1d1155205" };
            break;
          case "savannah":
            voiceConfig = { provider: "vapi", voiceId: "Savannah" };
            break;
          case "kentucky_man":
            voiceConfig = { provider: "cartesia", voiceId: "726d5ae5-055f-4c3d-8355-d9677de68937" };
            break;
          case "kentucky_woman":
            voiceConfig = { provider: "cartesia", voiceId: "4f8651b0-bbbd-46ac-8b37-5168c5923303" };
            break;
          default:
            voiceConfig = {
              provider: "cartesia",
              voiceId: "3b554273-4299-48b9-9aaf-eefd438e3941",
            };
            break;
        }
        if (extrasValue !== "none") {
          voiceConfig.experimentalControls = {
            emotion: [`${extrasValue}:highest`],
          };
        }
        console.log(toneValue);
        const assistantOverrides = {
          firstMessageMode: "assistant-speaks-first",
          model: {
            provider: "openai",
            model: "gpt-4",
            messages: [
              {
                role: "system",
                content: `Keep the tone ${toneValue} and non-intrusive. Ensure that the conversation flows naturally and dynamically rather than presenting questions as a rigid list. The AI should integrate pre-configured questions fluidly—adapting to context. Encourage honest responses without pressure.

Flow of Questions:
${extractedText}
make the questions strictly in a long conversational manner rather than just saying what the actual question is. You can change it to appear more conversational, even expand the question if it's too short, as if talking to a friend or co-worker. Avoid directly asking the question; guide the user towards thoughtful answers. If options are present, do not list them unless asked for.
Stay on Topic: The conversation must remain strictly within the scope of the survey.
If unrelated topics are introduced, respond with:
"I'm here to assist with the survey. Let's stay focused on the questions."
If persistence occurs, respond with:
"I’m sorry, but I can only respond to questions related to the survey."
If the answer is not satisfactory, include a follow-up like: "What did you find challenging about that?"
Open Feedback:
"Is there anything else you'd like to add or clarify?"
Closing:
"Thank you! We will carefully review your input and make improvements. If you think of anything else, feel free to share!"`,
              },
            ],
          },
          summaryPrompt:
            'You will be given a transcript of a call. Extract key information, including the user’s tone, and structure it into a concise JSON-like format. Keep it short:\n\n{\n  "summary": "",\n  "ratings": {\n    "TopicA": { "rating": 5, "comment": "" },\n    "TopicB": { "rating": 2, "comment": "" }\n  },\n  "overall": "",\n  "next_steps": ""\n}',
          voice: voiceConfig,
        };
        return vapiInstance
          .start(assistant, assistantOverrides)
          .then((response) => {
            console.log("VAPI Web call started:", response);
            globalCallId = response.id;
            return response;
          })
          .catch((error) => {
            console.error("Error starting web call:", error);
          });
      }

      function stopWebCall() {
        vapiInstance.stop();
        setTimeout(() => {
          pollCallDetails(globalCallId);
        }, 1000);
      }

      function pollCallDetails(callId, interval = 3000) {
        fetch("/call-details?call_id=" + callId, {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            Authorization: "Bearer " + apiKey,
          },
        })
          .then((response) => {
            if (!response.ok) {
              console.error(
                "Error fetching call details:",
                response.status,
                response.statusText
              );
              if (response.status === 403) {
                document.getElementById("call-summary").innerHTML =
                  "<h3>Error:</h3><p>Access forbidden. Check credentials.</p>";
              }
              throw new Error("HTTP error " + response.status);
            }
            return response.json();
          })
          .then((data) => {
            if (data.error) {
              console.error("Error in call details response:", data.error);
              return;
            }
            if (data.summary) {
              document.getElementById("call-summary").innerHTML =
                "<h3 class='font-semibold mb-2'>Call Summary</h3><p>" +
                data.summary +
                "</p>";
              // Once summary is available, show the Chat with Survey button
              let chatBtn = document.getElementById("chat-survey-btn");
              if (chatBtn) {
                chatBtn.classList.remove("hidden");
              }
            } else {
              console.log(
                "Summary not yet available; retrying in",
                interval,
                "ms"
              );
              setTimeout(() => pollCallDetails(callId, interval), interval);
            }
          })
          .catch((err) => {
            console.error("Error polling call details:", err);
          });
      }

      // PDF Upload & Extraction
      document
        .getElementById("upload-btn")
        .addEventListener("click", function () {
          const fileInput = document.getElementById("pdf-file");
          const file = fileInput.files[0];
          const statusEl = document.getElementById("upload-status");
          if (!file) {
            alert("Please select a PDF file.");
            return;
          }
          const formData = new FormData();
          formData.append("file", file);
          statusEl.textContent = "Uploading and extracting PDF...";
          fetch("/extract", {
            method: "POST",
            headers: { Authorization: "Bearer " + apiKey },
            body: formData,
          })
            .then((response) => response.json())
            .then((data) => {
              if (data.error) {
                statusEl.textContent = "Error: " + data.error;
                return;
              }
              statusEl.textContent = "Extraction complete.";
              const extractedText = data.text;
              document.getElementById("pdf-upload-section").style.display =
                "none";
              document.getElementById("call-section").style.display = "block";
              fetch("/start-call", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: "Bearer " + apiKey,
                },
                body: JSON.stringify({ text: extractedText }),
              })
                .then((response) => response.json())
                .then((callData) => {
                  if (callData.error) {
                    statusEl.textContent =
                      "Call start error: " + callData.error;
                    return;
                  }
                  const callId = callData.call_id;
                  pollCallDetails(callId);
                });
              startWebCall(extractedText);
            })
            .catch((err) => {
              statusEl.textContent = "Error during upload: " + err;
            });
        });

      

      // In the survey submission event listener, replace the assignment for window.latestChatRecordId:
//       document.getElementById("survey-submit-btn").addEventListener("click", function () {
//   const promptText = document.getElementById("survey-prompt").value;
//   const surveyLength = document.getElementById("survey-length").value;
//   const responseBox = document.getElementById("survey-response");
//   if (!promptText) {
//     alert("Please enter a survey prompt.");
//     return;
//   }
//   responseBox.value = "Waiting for response...";
//   fetch("/groq-chat", {
//     method: "POST",
//     headers: { "Content-Type": "application/json" },
//     body: JSON.stringify({
//       prompt: promptText,
//       survey_length: surveyLength,
//     }),
//   })
//     .then((response) => response.json())
//     .then((data) => {
//       if (data.error) {
//         responseBox.value = "Error: " + data.error;
//       } else {
//         responseBox.value = data.response;
//         // Update the Call Section heading with the survey heading.
//         document.getElementById("call-heading").textContent = `Call in Progress: ${data.survey_heading}`;
//         // Update the Chat Container heading with the survey heading.
//         document.getElementById("chat-heading").textContent = data.survey_heading;
//         // Store the history record id as a number.
//         window.latestRecordId = parseInt(data.record_id);
//         // Get the current chat record counter from localStorage.
//         let counter = parseInt(localStorage.getItem("chatRecordCounter"));
//         window.latestChatRecordId = counter; // Use this as the chat record id.
//         // Increment and store back to localStorage for next chat record.
//         localStorage.setItem("chatRecordCounter", (counter + 1).toString());
//         // Show Chat with Survey button if call summary is available.
//         let chatBtn = document.getElementById("chat-survey-btn");
//         if (chatBtn) {
//           chatBtn.classList.remove("hidden");
//         }
//       }
//     })
//     .catch((err) => {
//       responseBox.value = "Error: " + err;
//     });
// });
document.getElementById('survey-submit-btn').addEventListener('click', () => {
  // Clear any previous survey form content
  const surveyContainer = document.getElementById('survey-response');
  surveyContainer.innerHTML = '<p class="text-gray-600 mb-4">Loading survey...</p>';
  
  const promptText = document.getElementById("survey-prompt").value;
  const surveyLength = document.getElementById("survey-length").value;
  
  // Validate prompt
  if (!promptText) {
    alert("Please enter a survey prompt.");
    return;
  }
  /**
 * Renders the entire survey with each question in editable mode.
 * @param {Object} surveyData - The survey object with {survey_title, questions[]}.
 * @param {HTMLElement} container - The parent container to render into.
 */
/**
 * Renders the entire survey in a form so that all questions and answer fields are immediately editable.
 * @param {Object} surveyData - The survey object, containing survey_title and questions[].
 * @param {HTMLElement} container - The DOM element where the survey will be rendered.
 */
 function renderEditableSurvey(surveyData, container) {
  container.innerHTML = '';

  // Render an editable survey title
  const titleInput = document.createElement('input');
  titleInput.type = 'text';
  titleInput.value = surveyData.survey_title;
  titleInput.className = 'w-full mb-6 p-2 border rounded text-2xl font-bold';
  titleInput.addEventListener('input', () => {
    surveyData.survey_title = titleInput.value;
  });
  container.appendChild(titleInput);

  // Create a form container for questions
  const formEl = document.createElement('form');
  formEl.className = 'space-y-6';

  // Render each question in an editable manner
  surveyData.questions.forEach((question) => {
    const questionContainer = document.createElement('div');
    questionContainer.className = 'border p-4 rounded-lg bg-gray-50';

    // Editable question text
    const questionLabel = document.createElement('label');
    questionLabel.textContent = 'Question:';
    questionLabel.className = 'block font-semibold mb-1 text-gray-800';
    questionContainer.appendChild(questionLabel);

    const questionInput = document.createElement('input');
    questionInput.type = 'text';
    questionInput.value = question.question;
    questionInput.className = 'w-full p-2 border rounded mb-2';
    questionInput.addEventListener('input', () => {
      question.question = questionInput.value;
    });
    questionContainer.appendChild(questionInput);

    // Editable question type dropdown
    const typeLabel = document.createElement('label');
    typeLabel.textContent = 'Type:';
    typeLabel.className = 'block font-semibold mb-1 text-gray-800';
    questionContainer.appendChild(typeLabel);

    const typeSelect = document.createElement('select');
    typeSelect.className = 'w-full p-2 border rounded mb-2';
    ['multiple_choice', 'short_answer', 'rating', 'paragraph'].forEach(t => {
      const opt = document.createElement('option');
      opt.value = t;
      opt.textContent = t;
      if (t === question.type) opt.selected = true;
      typeSelect.appendChild(opt);
    });
    // When the type changes, update the question and prompt for options if needed.
    typeSelect.addEventListener('change', () => {
      const oldType = question.type;
      question.type = typeSelect.value;
      // If switching from text-based (paragraph/short_answer) to option-based (multiple_choice/rating)
      if ((oldType === 'paragraph' || oldType === 'short_answer') &&
          (question.type === 'multiple_choice' || question.type === 'rating')) {
        if (confirm('You changed from a text-based answer to an option-based answer. Do you want to add options now?')) {
          const numOptions = parseInt(prompt('How many options do you want to add?', '2'), 10);
          if (!isNaN(numOptions) && numOptions > 0) {
            question.options = [];
            for (let i = 0; i < numOptions; i++) {
              question.options.push(`Option ${i + 1}`);
            }
          } else {
            question.options = [];
          }
        } else {
          question.options = [];
        }
      } else if ((oldType === 'multiple_choice' || oldType === 'rating') &&
                 (question.type === 'paragraph' || question.type === 'short_answer')) {
        question.options = [];
      }
      // Re-render the options and answer section based on the new type
      renderOptionsSection(question, optionsContainer, answerContainer);
    });
    questionContainer.appendChild(typeSelect);

    // Container for options (only applicable if type is multiple_choice or rating)
    const optionsContainer = document.createElement('div');
    optionsContainer.className = 'mb-2';
    questionContainer.appendChild(optionsContainer);

    // Container for the answer input field
    const answerContainer = document.createElement('div');
    answerContainer.className = 'mb-2';
    questionContainer.appendChild(answerContainer);

    // Render the options (if applicable) and the answer field
    renderOptionsSection(question, optionsContainer, answerContainer);

    formEl.appendChild(questionContainer);
  });

  container.appendChild(formEl);
}

/**
 * Renders the options UI (if applicable) and the answer input field.
 * @param {Object} question - The question object.
 * @param {HTMLElement} optionsContainer - Container for option editing.
 * @param {HTMLElement} answerContainer - Container for the answer field.
 */
function renderOptionsSection(question, optionsContainer, answerContainer) {
  // Render options for multiple_choice or rating types
  optionsContainer.innerHTML = '';
  if (question.type === 'multiple_choice' || question.type === 'rating') {
    if (!Array.isArray(question.options)) {
      question.options = [];
    }
    question.options.forEach((opt, idx) => {
      const optRow = document.createElement('div');
      optRow.className = 'flex items-center mb-1';

      const optInput = document.createElement('input');
      optInput.type = 'text';
      optInput.value = opt;
      optInput.className = 'flex-1 p-1 border rounded mr-2';
      optInput.addEventListener('input', () => {
        question.options[idx] = optInput.value;
        // Re-render the answer field to reflect updated options
        renderAnswerField(question, answerContainer);
      });
      optRow.appendChild(optInput);

      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.textContent = 'X';
      removeBtn.className = 'bg-red-500 text-white px-2 rounded';
      removeBtn.addEventListener('click', () => {
        question.options.splice(idx, 1);
        renderOptionsSection(question, optionsContainer, answerContainer);
      });
      optRow.appendChild(removeBtn);

      optionsContainer.appendChild(optRow);
    });
    // Button to add a new option manually
    const addOptionBtn = document.createElement('button');
    addOptionBtn.type = 'button';
    addOptionBtn.textContent = 'Add Option';
    addOptionBtn.className = 'bg-green-500 text-white px-2 py-1 rounded';
    addOptionBtn.addEventListener('click', () => {
      question.options.push('New Option');
      renderOptionsSection(question, optionsContainer, answerContainer);
    });
    optionsContainer.appendChild(addOptionBtn);
  }

  // Render the answer input field
  renderAnswerField(question, answerContainer);
}

/**
 * Renders the answer field based on the question type.
 * For multiple_choice or rating, a dropdown is shown; for short_answer an input field; for paragraph a textarea.
 */
function renderAnswerField(question, container) {
  container.innerHTML = '';
  const answerLabel = document.createElement('label');
  answerLabel.textContent = 'Answer:';
  answerLabel.className = 'block font-semibold text-gray-700 mb-1';
  container.appendChild(answerLabel);

  let answerInput;
  if (question.type === 'multiple_choice' || question.type === 'rating') {
    answerInput = document.createElement('select');
    answerInput.className = 'w-full p-2 border rounded';
    const defaultOpt = document.createElement('option');
    defaultOpt.value = '';
    defaultOpt.textContent = 'Select an answer';
    answerInput.appendChild(defaultOpt);
    if (Array.isArray(question.options)) {
      question.options.forEach(opt => {
        const optEl = document.createElement('option');
        optEl.value = opt;
        optEl.textContent = opt;
        if (question.answer === opt) optEl.selected = true;
        answerInput.appendChild(optEl);
      });
    }
  } else {
    if (question.type === 'paragraph') {
      answerInput = document.createElement('textarea');
      answerInput.rows = 3;
    } else {
      answerInput = document.createElement('input');
      answerInput.type = 'text';
    }
    answerInput.value = question.answer || '';
    answerInput.className = 'w-full p-2 border rounded';
  }
  answerInput.addEventListener('input', () => {
    question.answer = answerInput.value;
  });
  container.appendChild(answerInput);
}


/**
 * Renders a single question. Allows toggling between display and edit modes.
 * @param {Object} question - { id, question, type, options[], answer }
 * @returns {HTMLElement} The DOM element representing this question.
 */
 function renderQuestion(question) {
  // A wrapper div for this question
  const questionContainer = document.createElement('div');
  questionContainer.className = 'border p-4 rounded-lg bg-gray-50 relative mb-4';

  // Determine if we are in edit mode for question properties
  if (question.editMode === undefined) {
    question.editMode = false;
  }

  // Container for question properties (text, type, options)
  const propertiesContainer = document.createElement('div');

  if (!question.editMode) {
    // DISPLAY MODE: show question text and details as read-only
    const qText = document.createElement('p');
    qText.textContent = `${question.question} (Type: ${question.type})`;
    qText.className = 'mb-2 font-semibold text-gray-800';
    propertiesContainer.appendChild(qText);

    // If the question is MCQ or rating, display the options
    if ((question.type === 'multiple_choice' || question.type === 'rating') && Array.isArray(question.options)) {
      question.options.forEach((opt) => {
        const optEl = document.createElement('p');
        optEl.textContent = `• ${opt}`;
        optEl.className = 'ml-4 text-gray-600';
        propertiesContainer.appendChild(optEl);
      });
    }

    // Edit button for properties (question text, type, options)
    const editBtn = document.createElement('button');
    editBtn.type = 'button';
    editBtn.textContent = 'Edit';
    editBtn.className = 'absolute top-2 right-2 bg-blue-500 text-white px-2 py-1 rounded';
    editBtn.addEventListener('click', () => {
      question.editMode = true;
      reRenderQuestion(question, questionContainer);
    });
    questionContainer.appendChild(editBtn);
  } else {
    // EDIT MODE: show editable fields for question properties
    // Editable question text
    const questionLabel = document.createElement('label');
    questionLabel.textContent = 'Question:';
    questionLabel.className = 'block font-semibold text-gray-800 mb-1';
    propertiesContainer.appendChild(questionLabel);

    const questionInput = document.createElement('input');
    questionInput.type = 'text';
    questionInput.value = question.question;
    questionInput.className = 'w-full p-2 border rounded mb-2';
    questionInput.addEventListener('input', () => {
      question.question = questionInput.value;
    });
    propertiesContainer.appendChild(questionInput);

    // Editable question type dropdown
    const typeLabel = document.createElement('label');
    typeLabel.textContent = 'Type:';
    typeLabel.className = 'block font-semibold text-gray-800 mb-1';
    propertiesContainer.appendChild(typeLabel);

    const typeSelect = document.createElement('select');
    typeSelect.className = 'w-full p-2 border rounded mb-2';
    ['multiple_choice', 'short_answer', 'rating', 'paragraph'].forEach(t => {
      const opt = document.createElement('option');
      opt.value = t;
      opt.textContent = t;
      if (t === question.type) opt.selected = true;
      typeSelect.appendChild(opt);
    });
    propertiesContainer.appendChild(typeSelect);

    // Options container for MCQ/rating types
    const optionsContainer = document.createElement('div');
    optionsContainer.className = 'mb-2';

    function renderOptionsUI() {
      optionsContainer.innerHTML = '';
      if (question.type === 'multiple_choice' || question.type === 'rating') {
        if (!Array.isArray(question.options)) {
          question.options = [];
        }
        question.options.forEach((opt, index) => {
          const optRow = document.createElement('div');
          optRow.className = 'flex items-center mb-1';

          const optInput = document.createElement('input');
          optInput.type = 'text';
          optInput.value = opt;
          optInput.className = 'flex-1 p-1 border rounded mr-2';
          optInput.addEventListener('input', () => {
            question.options[index] = optInput.value;
            // If answer is selected, update dropdown later
            renderAnswerField(question, answerContainer);
          });
          optRow.appendChild(optInput);

          const removeBtn = document.createElement('button');
          removeBtn.type = 'button';
          removeBtn.textContent = 'X';
          removeBtn.className = 'bg-red-500 text-white px-2 rounded';
          removeBtn.addEventListener('click', () => {
            question.options.splice(index, 1);
            renderOptionsUI();
            renderAnswerField(question, answerContainer);
          });
          optRow.appendChild(removeBtn);

          optionsContainer.appendChild(optRow);
        });
        // "Add Option" button
        const addOptionBtn = document.createElement('button');
        addOptionBtn.type = 'button';
        addOptionBtn.textContent = 'Add Option';
        addOptionBtn.className = 'bg-green-500 text-white px-2 py-1 rounded';
        addOptionBtn.addEventListener('click', () => {
          question.options.push('New Option');
          renderOptionsUI();
          renderAnswerField(question, answerContainer);
        });
        optionsContainer.appendChild(addOptionBtn);
      }
    }

    renderOptionsUI();
    propertiesContainer.appendChild(optionsContainer);

    // Save button to save the question properties changes
    const saveBtn = document.createElement('button');
    saveBtn.type = 'button';
    saveBtn.textContent = 'Save';
    saveBtn.className = 'bg-blue-500 text-white px-3 py-1 rounded';
    saveBtn.addEventListener('click', () => {
      // If switching to a text-based type, clear options
      if (question.type === 'short_answer' || question.type === 'paragraph') {
        question.options = [];
      }
      question.editMode = false;
      reRenderQuestion(question, questionContainer);
    });
    propertiesContainer.appendChild(saveBtn);

    // Listen for changes to typeSelect to prompt for options if needed
    typeSelect.addEventListener('change', () => {
      const oldType = question.type;
      question.type = typeSelect.value;
      if ((oldType === 'paragraph' || oldType === 'short_answer') &&
          (question.type === 'multiple_choice' || question.type === 'rating')) {
        if (confirm('You changed from a text-based answer to an option-based answer. Do you want to add options now?')) {
          const numOptions = parseInt(prompt('How many options do you want to add?', '2'), 10);
          if (!isNaN(numOptions) && numOptions > 0) {
            question.options = [];
            for (let i = 0; i < numOptions; i++) {
              question.options.push(`Option ${i + 1}`);
            }
          } else {
            question.options = [];
          }
        } else {
          question.options = [];
        }
      } else if ((oldType === 'multiple_choice' || oldType === 'rating') &&
                 (question.type === 'paragraph' || question.type === 'short_answer')) {
        question.options = [];
      }
      renderOptionsUI();
      renderAnswerField(question, answerContainer);
    });
  }

  // Append the properties container (question text, type, options)
  questionContainer.appendChild(propertiesContainer);

  // --- ANSWER FIELD: Always Editable ---
  // Create a container for the answer field
  const answerContainer = document.createElement('div');
  answerContainer.className = 'mt-2';
  renderAnswerField(question, answerContainer);
  questionContainer.appendChild(answerContainer);

  return questionContainer;
}

/**
 * Renders the answer field based on the question type.
 * For multiple_choice or rating, a dropdown is used; for short_answer an input field; for paragraph a textarea.
 */
function renderAnswerField(question, container) {
  container.innerHTML = '';
  const answerLabel = document.createElement('label');
  answerLabel.textContent = 'Answer:';
  answerLabel.className = 'block font-semibold text-gray-700 mb-1';
  container.appendChild(answerLabel);

  let answerInput;
  if (question.type === 'multiple_choice' || question.type === 'rating') {
    answerInput = document.createElement('select');
    answerInput.className = 'w-full p-2 border rounded';
    const defaultOpt = document.createElement('option');
    defaultOpt.value = '';
    defaultOpt.textContent = 'Select an answer';
    answerInput.appendChild(defaultOpt);
    if (Array.isArray(question.options)) {
      question.options.forEach(opt => {
        const optEl = document.createElement('option');
        optEl.value = opt;
        optEl.textContent = opt;
        if (question.answer === opt) {
          optEl.selected = true;
        }
        answerInput.appendChild(optEl);
      });
    }
  } else {
    // For short_answer use an input and for paragraph use a textarea.
    if (question.type === 'paragraph') {
      answerInput = document.createElement('textarea');
      answerInput.rows = 3;
    } else {
      answerInput = document.createElement('input');
      answerInput.type = 'text';
    }
    answerInput.value = question.answer || '';
    answerInput.className = 'w-full p-2 border rounded';
  }
  answerInput.addEventListener('input', () => {
    question.answer = answerInput.value;
  });
  container.appendChild(answerInput);
}

/**
 * Helper to re-render a question in the same container.
 */
function reRenderQuestion(question, container) {
  container.innerHTML = '';
  const newQuestionEl = renderQuestion(question);
  container.appendChild(newQuestionEl);
}


/**
 * Helper to re-render a question in the same container after toggling edit mode.
 */
function reRenderQuestion(question, container) {
  container.innerHTML = '';
  const newQuestionEl = renderQuestion(question);
  container.appendChild(newQuestionEl);
}


/**
 * Helper to re-render a question in the same container after toggling edit mode.
 */
function reRenderQuestion(question, container) {
  container.innerHTML = '';
  const newQuestionEl = renderQuestion(question);
  container.appendChild(newQuestionEl);
}


/**
 * Helper to re-render a question in the same container after toggling edit mode.
 */
function reRenderQuestion(question, container) {
  // Clear container
  container.innerHTML = '';
  // Re-append fresh version of question
  const newQuestionEl = renderQuestion(question);
  container.appendChild(newQuestionEl);
}

  // Fetch survey JSON data from the "groq-chat" route
  fetch("/groq-chat", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      prompt: promptText,
      survey_length: surveyLength,
    }),
  })
    .then(response => response.json())
    .then(data => {
      // Clear the container before rendering new content
      surveyContainer.innerHTML = '';
      
      // Check if the survey data exists
      if (data && data.survey) {
         // Store globally for easy editing
      window.currentSurvey = data.survey; 

// Render the editable version
renderEditableSurvey(window.currentSurvey, surveyContainer);
        // Update headings using the survey heading from the response
        document.getElementById("call-heading").textContent = `Call in Progress: ${data.survey.survey_title}`;
        document.getElementById("chat-heading").textContent = data.survey.survey_title;
        
        // Store the history record id and update the chat record counter
        window.latestRecordId = parseInt(data.record_id);
        let counter = parseInt(localStorage.getItem("chatRecordCounter"));
        window.latestChatRecordId = counter; // Use this as the chat record id
        localStorage.setItem("chatRecordCounter", (counter + 1).toString());
        let chatBtn = document.getElementById("chat-survey-btn");
        if (chatBtn) {
          chatBtn.classList.remove("hidden");
        }
        
        // Create and append the survey title
        const titleEl = document.createElement('h1');
        titleEl.textContent = data.survey.survey_title;
        titleEl.className = 'text-2xl font-bold mb-6';
        surveyContainer.appendChild(titleEl);
        
        // Create a form element to contain all questions
        const formEl = document.createElement('form');
        formEl.className = 'space-y-6';
        
        // Iterate over each question and render based on its type
        data.survey.questions.forEach(question => {
          // Container for an individual question
          const questionContainer = document.createElement('div');
          questionContainer.className = 'border p-4 rounded-lg bg-gray-50';
          
          // Display the question text
          const questionText = document.createElement('p');
          questionText.textContent = question.question;
          questionText.className = 'mb-3 font-semibold text-gray-800';
          questionContainer.appendChild(questionText);
          
          // Render elements based on question type
          if (question.type === 'multiple_choice') {
            // Create radio buttons for each option
            question.options.forEach((option, index) => {
              const optionContainer = document.createElement('div');
              optionContainer.className = 'mcq-option';
              
              const radioInput = document.createElement('input');
              radioInput.type = 'radio';
              radioInput.name = 'question_' + question.id;
              radioInput.value = option;
              radioInput.id = `q${question.id}_option${index}`;
              radioInput.className = 'mr-2';
              
              const label = document.createElement('label');
              label.htmlFor = radioInput.id;
              label.textContent = option;
              label.className = 'text-gray-700';
              
              optionContainer.appendChild(radioInput);
              optionContainer.appendChild(label);
              questionContainer.appendChild(optionContainer);
            });
          } else if (question.type === 'short_answer') {
            // Create a single-line text input
            const inputEl = document.createElement('input');
            inputEl.type = 'text';
            inputEl.name = 'question_' + question.id;
            inputEl.className = 'w-full p-2 border rounded focus:outline-none focus:ring';
            questionContainer.appendChild(inputEl);
          } else if (question.type === 'rating') {
            // If options are provided, render as a dropdown
            if (question.options && question.options.length > 0) {
              const selectEl = document.createElement('select');
              selectEl.name = 'question_' + question.id;
              selectEl.className = 'w-full p-2 border rounded focus:outline-none focus:ring';
              
              // Default placeholder option
              const defaultOption = document.createElement('option');
              defaultOption.value = '';
              defaultOption.textContent = 'Select rating';
              selectEl.appendChild(defaultOption);
              
              question.options.forEach(option => {
                const optionEl = document.createElement('option');
                optionEl.value = option;
                optionEl.textContent = option;
                selectEl.appendChild(optionEl);
              });
              questionContainer.appendChild(selectEl);
            } else {
              // Alternatively, render a series of buttons (e.g., 1-5)
              const ratingContainer = document.createElement('div');
              ratingContainer.className = 'flex space-x-2';
              for (let i = 1; i <= 5; i++) {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.textContent = i;
                btn.className = 'px-3 py-1 border rounded hover:bg-gray-200';
                ratingContainer.appendChild(btn);
              }
              questionContainer.appendChild(ratingContainer);
            }
          } else if (question.type === 'paragraph') {
            // Render a multi-line textarea
            const textareaEl = document.createElement('textarea');
            textareaEl.name = 'question_' + question.id;
            textareaEl.rows = 4;
            textareaEl.className = 'w-full p-2 border rounded focus:outline-none focus:ring';
            questionContainer.appendChild(textareaEl);
          }
          
          // Append the question container to the form
          formEl.appendChild(questionContainer);
        });
        
        // Append the completed form to the survey container
        surveyContainer.appendChild(formEl);
      } else {
        surveyContainer.innerHTML = '<p class="text-red-600">Survey data not found.</p>';
      }
    })
    .catch(error => {
      console.error('Error fetching survey data:', error);
      surveyContainer.innerHTML = '<p class="text-red-600">Error loading survey.</p>';
    });
});


      // Send Survey Response to Voice AI
      document
        .getElementById("send-voice-btn")
        .addEventListener("click", function () {
          const responseText = document.getElementById("survey-response").textContent;
          if (!responseText) {
            alert("No response text available to send.");
            return;
          }
          // Hide chat container if visible.
          document.getElementById("chat-container").classList.add("hidden");
          // Ensure the Voice AI container is visible.
          document.getElementById("call-section").classList.remove("hidden");
          fetch("/start-call", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: "Bearer " + apiKey,
            },
            body: JSON.stringify({ text: responseText }),
          })
            .then((response) => response.json())
            .then((callData) => {
              if (callData.error) {
                return;
              }
              const callId = callData.call_id;
              pollCallDetails(callId);
            });
          startWebCall(responseText);
          setTimeout(() => {
            document
              .getElementById("call-section")
              .scrollIntoView({ behavior: "smooth" });
          }, 300);
        });

      // Stop call
      document
        .getElementById("stop-btn")
        .addEventListener("click", function () {
          stopWebCall();
        });

      // Chat with Survey button functionality: Hide call section and show chat container.
      document
        .getElementById("chat-survey-btn")
        .addEventListener("click", function () {
          document.getElementById("call-section").classList.add("hidden");
          document.getElementById("chat-container").classList.remove("hidden");
          const chatMessages = document.getElementById("chat-messages");
          // Start with an initial greeting and include the chat record id in the context if needed.
          chatMessages.innerHTML =
            "<p class='text-green-600 font-semibold'>Bot: Hi, let's start the survey. Are you ready?</p>";
            document.getElementById("chat-container").scrollIntoView({ behavior: "smooth" });

        });

      // Back to Voice AI link in chat container
      document
        .getElementById("back-to-voice")
        .addEventListener("click", function (e) {
          e.preventDefault();
          document.getElementById("chat-container").classList.add("hidden");
          document.getElementById("call-section").classList.remove("hidden");
        });

      // Chat send functionality for the Chat with Survey interface.
      document.addEventListener("DOMContentLoaded", function () {
        document
          .getElementById("chat-send-btn")
          .addEventListener("click", function () {
            const chatInput = document.getElementById("chat-input");
            const question = chatInput.value.trim();
            if (!question) return;
            const chatMessages = document.getElementById("chat-messages");

            // Append the user's message.
            const userMsg = document.createElement("div");
            userMsg.textContent = "You: " + question;
            userMsg.className = "text-blue-600 font-semibold my-1";
            chatMessages.appendChild(userMsg);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            const surveyResponseText =
              document.getElementById("survey-response").textContent;
            // Use the latest raw transcript as context.
            const rawTranscript = window.latestRawTranscript || "";
            fetch("/chat_with_survey", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                question: question,
                survey_response: surveyResponseText,
                record_id: window.latestChatRecordId,
              }),
            })
              .then((response) => response.json())
              .then((data) => {
                const botMsg = document.createElement("div");
                if (data.error) {
                  botMsg.textContent = "Error: " + data.error;
                  botMsg.className = "text-red-600 font-semibold my-1";
                } else {
                  botMsg.textContent = "Bot: " + data.response;
                  botMsg.className = "text-green-600 font-semibold my-1";
                  // Optionally update the latest raw transcript with the new context.
                  window.latestRawTranscript += "\n" + data.response;
                }
                chatMessages.appendChild(botMsg);
                chatMessages.scrollTop = chatMessages.scrollHeight;
              })
              .catch((error) => {
                const errorEl = document.createElement("div");
                errorEl.textContent = "Error: " + error;
                errorEl.className = "text-red-600 font-semibold my-1";
                chatMessages.appendChild(errorEl);
              });
            chatInput.value = "";
          });
      });

      // Prefill fields if URL has parameters.
      document.addEventListener("DOMContentLoaded", function () {
        const params = new URLSearchParams(window.location.search);
        const prompt = params.get("prompt");
        const promptSummary = params.get("prompt_summary");
        if (prompt) {
          document.getElementById("survey-prompt").value = prompt;
        }
        if (promptSummary) {
          document.getElementById("survey-response").value = promptSummary;
        }
      });
      // Stop Survey button functionality
      document
        .getElementById("stop-survey-btn")
        .addEventListener("click", function () {
          if (!window.latestChatRecordId) {
            alert("No chat record available.");
            return;
          }
          // Send a POST request to /stop-survey with the chat record id.
          fetch("/stop-survey", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ record_id: window.latestChatRecordId }),
          })
            .then((response) => response.json())
            .then((data) => {
              if (data.error) {
                alert("Error stopping survey: " + data.error);
              } else {
                // Optionally, show the summary to the user
                alert("Survey stopped");
                // You can also disable further chat input if needed:
                document.getElementById("chat-input").disabled = true;
                document.getElementById("chat-send-btn").disabled = true;
              }
            })
            .catch((err) => {
              alert("Error: " + err);
            });
        });


        document.getElementById("public-survey-link").addEventListener("click", function(e) {
  e.preventDefault();
  
  // Check if survey response has been generated.
  if (!window.latestRecordId || !window.latestChatRecordId) {
    alert("Please complete the survey before copying the public survey link.");
    return;
  }
  
  // Retrieve the record IDs from the global variables.
  let recordid = window.latestRecordId;
  let chatrecordid = window.latestChatRecordId;
  
  // Construct the public survey URL with the record IDs as query parameters.
  let publicUrl = `${window.location.origin}/public_survey?recordid=${recordid}&chatrecordid=${chatrecordid}`;
  
  // Copy the URL to clipboard using the Clipboard API.
  navigator.clipboard.writeText(publicUrl)
    .then(function() {
      alert("Public survey link copied to clipboard:\n" + publicUrl);
    })
    .catch(function(err) {
      alert("Error copying public survey link: " + err);
    });
});



    </script>
  </body>
</html>
