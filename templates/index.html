<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>VAPI Integrated App</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* Ripple styles for both avatars */
#user-avatar-ripple,
#ai-avatar-ripple {
  position: absolute;
  inset: 0;
  border-radius: 9999px;
  pointer-events: none;
  transform: scale(1);
  opacity: 0;
  transition: transform 0.1s ease, opacity 0.1s ease;
}

/* (Optional) Adjust the border thickness/colors as needed */
#user-avatar-ripple {
  border: 4px solid #3b82f6; /* Blue for user */
}
#ai-avatar-ripple {
  border: 4px solid #10B981; /* Green for AI */
}
      /* Hide the Vapi call button injected from the CDN */
      #vapi-icon-container,
      #vapi-support-btn {
        display: none !important;
      }
      /* Survey section styling */
      #survey-section textarea {
        margin-bottom: 10px;
      }
      /* Updated survey-response styling */
#survey-response {
  width: 100%;
  max-height: 500px; /* Prevent container from growing too tall */
  overflow-y: auto;  /* Add vertical scrollbar if content overflows */
  background-color: #fff;
  padding: 1.5rem;
  border-radius: 0.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  margin-bottom: 1.5rem; /* Extra space to avoid overlapping with call section */
}
/* Styling for multiple-choice options */
/* Multiple-choice option container */
/* Container for each radio button + label pair */
.mcq-option {
  display: flex;               /* Put the radio button + label in a row */
  align-items: center;         /* Vertically center them */
  justify-content: flex-start; /* Keep them on the left side */
  margin-bottom: 0.5rem;       /* Spacing between each option */
  width: auto;                 /* Donâ€™t force 100% width for each option */
}

/* Radio input spacing */
.mcq-option input[type="radio"] {
  margin-right: 0.5rem;
  width: auto; 
}

/* Ensure labels donâ€™t take up 100% width */
.mcq-option label {
  width: auto;
  display: inline-block; 
}



      select,
      textarea,
      input {
        background-color: #fffdfb;
        border: 1px solid #e5e7eb;
        border-radius: 4px;
        width: 100%;
        padding: 8px 12px;
        color: #374151;
      }
      select {
        appearance: none;
        background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
        background-position: right 0.5rem center;
        background-repeat: no-repeat;
        background-size: 1.5em 1.5em;
        padding-right: 2.5rem;
      }
      textarea:focus,
      select:focus {
        outline: none;
        border-color: #e5e7eb;
        box-shadow: 0 0 0 1px #e5e7eb;
      }
      .volume-bar {
        width: 4px;
        height: 30px;
        background-color: #d1d5db;
      }
      .volume-bar.active {
        background-color: #3b82f6;
      }
    </style>
  </head>
  <body class="bg-[#F6F6F6]">
    <div class="flex min-h-screen">
      <!-- Sidebar -->
      <aside
        class="w-16 bg-[#210803] text-white flex flex-col items-center p-4"
      >
        <!-- History Icon -->
        <a
          href="/history"
          class="mt-8 mb-4 hover:text-gray-400 text-2xl text-center"
          title="View History"
        >
          <img
            src="{{ url_for('static', filename='images/history.png') }}"
            alt="History Icon"
            class="w-8 h-8 transform translate-x-2"
          />
          <span class="text-sm mt-2 block font-bold">History</span>
        </a>
        <!-- Analysis Icon -->
        <a
          href="/analysis"
          class="mb-4 hover:text-gray-400 text-2xl text-center"
          title="View Analysis"
        >
          <img
            src="{{ url_for('static', filename='images/graph.png') }}"
            alt="Analysis Icon"
            class="w-8 h-8 transform translate-x-2"
          />
          <span class="text-sm mt-2 block font-bold">Analysis</span>
        </a>
        <!-- New Public Survey Link element -->
<!-- <a id="public-survey-link" href="#" class="mt-2 text-xs hover:text-gray-400 text-center" title="Public Survey Link">
  Public Survey Link
</a>
<a
          href="#"
          id="public-survey-link",
          class="mb-4 hover:text-gray-400 text-2xl text-center"
          title="Public Survey Link"
        >
          <img
            src="{{ url_for('static', filename='images/people.png') }}"
            alt="Survey Icon"
            class="w-8 h-8 transform translate-x-2"
          />
          <span class="text-sm mt-2 block font-bold">Public Survey Link</span>
        </a> -->

      </aside>
      <!-- Main Container -->
      <div class="flex-1">
        <div class="max-w-7xl mx-auto px-4 py-6 grid grid-cols-4 gap-6">
          <!-- Survey Prompt Section -->
          <div class="bg-white p-6 rounded-lg shadow-sm space-y-6 h-full">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">
              Create a Survey Prompt
            </h2>
            <!-- Prompt Input -->
            <div class="mb-4">
              <label class="block text-sm text-gray-600 mb-1"
                >Enter Prompt:</label
              >
              <textarea
                  id="survey-prompt"
                  rows="4"
                  placeholder="Enter your survey prompt here..."
                  class="w-full border  text-sm border-gray-300 rounded-xl px-3 py-2"
                ></textarea>

             
            </div>
            <!-- Dropdowns -->
            <div class="grid grid-cols-2 gap-4 mb-4">
              <div>
                <label class="block text-sm text-gray-600 mb-1">Accent:</label>
                <select
                  id="accent"
                  class="w-full text-sm border border-gray-300 rounded-xl px-3 py-2"
                >
                  <option value="indian_lady">Indian Lady</option>
                  <option value="indian_man">Indian Man</option>
                  <option value="british_lady">British Female</option>
                  <option value="british_man">British Man</option>
                  <option value="anime_girl">Anime Girl</option>
                  <option value="middle_east_women">
                    Middle Eastern Women
                  </option>
                  <option value="australian_women">Australian Women</option>
                  <option value="california_girl">California Girl</option>
                  <option value="new_york_man">New York Man</option>
                  <option value="new_york_women">New York Women</option>
                  <option value="savannah">American Southern Accent</option>
                  <option value="kentucky_man">Kentucky Man</option>
                  <option value="kentucky_woman">Kentucky Woman</option>
                  <option value="sesame">Sesame</option>
                </select>
              </div>
              <div>
                <label class="block text-sm text-gray-600 mb-1"
                  >Survey Length:</label
                >
                <select
                  id="survey-length"
                  class="w-full text-sm border border-gray-300 rounded-xl px-3 py-2"
                >
                  <option value="short">Short (2 mins)</option>
                  <option value="medium">Medium (3-5 mins)</option>
                  <option value="long">Long (5+ mins)</option>
                </select>
              </div>
            </div>
            <div class="grid grid-cols-2 gap-4 mb-4">
              <div>
                <label class="block text-sm text-gray-600 mb-1">Tone:</label>
                <select
                  id="tone"
                  class="w-full text-sm border border-gray-300 rounded-xl px-3 py-2"
                >
                  <option value="neutral">Neutral</option>
                  <option value="friendly">Friendly</option>
                  <option value="professional">Professional</option>
                </select>
              </div>
              <div>
                <label class="block text-sm text-gray-600 mb-1">Extras:</label>
                <select
                  id="extras"
                  class="w-full text-sm border border-gray-300 rounded-xl px-3 py-2"
                >
                  <option value="none">None</option>
                  <option value="anger">Anger</option>
                  <option value="positivity">Positivity</option>
                  <option value="surprise">Surprise</option>
                  <option value="sadness">Sadness</option>
                  <option value="curiosity">Curiosity</option>
                </select>
              </div>
            </div>
            <!-- Survey Submission Button -->
            <div class="flex space-x-4 mt-4">
              <button
                id="survey-submit-btn"
                class="bg-[#FF714C] hover:bg-[#f2613c] text-white py-2 px-4 rounded-full transition-colors font-bold"
              >
                Submit Survey Prompt
              </button>
            </div>
            <!-- Integrated PDF Upload -->
            <div id="pdf-upload-section" class="mt-6 border-t pt-6">
              <h3 class="text-xl font-semibold text-gray-700">Or Upload PDF</h3>
              <div class="flex items-center gap-4">
                <input
                  type="file"
                  id="pdf-file"
                  accept="application/pdf"
                  class="flex-1 px-3 py-2 text-sm text-gray-700"
                />
                <button
                  id="upload-btn"
                  class="bg-[#FF714C] text-white py-2 px-4 rounded-full hover:bg-[#f2613c] transition-colors font-bold"
                >
                  Extract
                </button>
              </div>
              <p id="upload-status" class="text-sm text-gray-600 mt-2"></p>
            </div>
          </div>
          <!-- Main Content Area (Survey Response) -->
          <div class="col-span-3 h-screen flex flex-col p-6 pt-0">
            <div class="flex-1 flex flex-col ">
              <label
                class="mb-2 text-sm font-medium text-gray-700"
                for="survey-response"
              >
                Response:
              </label>
              <button
              id="toggle-mode-btn"
              class="hidden absolute top-4 right-4 bg-gray-800 text-white px-3 py-1 rounded"
            >
              <!-- This text will change dynamically based on mode -->
            </button>
              <div id="survey-response" class=" flex-1 bg-white p-6 rounded-lg shadow-md mb-0"></div>
            </div>
            <!-- Buttons for Voice AI and Chat with Survey -->
            <div class="flex space-x-4 mt-4 self-end">
              <!-- New Copy Public Survey Link Button -->
  <button
  id="copy-public-survey-link-btn"
  class="bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-md transition-colors font-semibold"
>
  Copy Public Survey Link
</button>
              <button
                id="send-voice-btn"
                class="bg-[#FF714C] hover:bg-[#f2613c] text-white py-2 px-4 rounded-md transition-colors font-semibold"
              >
                Send to Voice AI
              </button>
              <button
                id="chat-survey-btn"
                class="bg-green-500 hover:bg-green-600 text-white py-2 px-4 rounded-md transition-colors font-semibold "
              >
                Chat with Survey
              </button>
            </div>
          </div>
        </div>
        <!-- Call Section -->
        <!-- Call Section -->
<!-- Call Section with Two Avatars -->
<div id="call-section" class="hidden w-full max-w-3xl mx-auto my-8 p-6 bg-white rounded-lg shadow-lg">
  <div class="flex justify-between items-center mb-4">
    <h2 id="call-heading" class="text-xl font-semibold text-gray-700">Call in Progress</h2>
    <div id="call-timer" class="text-gray-800 font-semibold bg-gray-100 px-2 py-1 rounded shadow">00:00</div>
  </div>
  <p id="assistant-status" class="text-sm text-gray-600 mb-12">Assistant Status: Not Speaking</p>
  
  <!-- Two avatars side by side -->
  <div class="flex justify-around items-center mb-4">
    <!-- User Avatar with Ripple Effect -->
    <div id="user-avatar-wrapper" class="relative flex flex-col items-center">
      <img id="user-avatar" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTi2haw1278i40sszGwCvy7LKP3j2KqLTnPJg&s" alt="User Avatar" class="w-24 h-24 rounded-full relative z-10">
      <!-- User Ripple (initially hidden) -->
      <div id="user-avatar-ripple" class="absolute inset-0 border-4 border-blue-500 rounded-full pointer-events-none"
           style="transform: scale(1); opacity: 0; transition: transform 0.1s ease, opacity 0.1s ease;"></div>
      <!-- <span class="mt-2 text-gray-700 font-medium">You</span> -->
    </div>
    <!-- AI Avatar with Ripple Effect -->
    <div id="ai-avatar-wrapper" class="relative flex flex-col items-center">
      <img id="ai-avatar" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcScCVSfGCuArq-pdk5dklWyrOB-6thHwQAyCA&s" alt="AI Avatar" class="w-24 h-24 rounded-full relative z-10">
      <!-- AI Ripple (initially hidden) -->
      <div id="ai-avatar-ripple" class="absolute inset-0 border-4 border-green-500 rounded-full pointer-events-none"
           style="transform: scale(1); opacity: 0; transition: transform 0.1s ease, opacity 0.1s ease;"></div>
      <!-- <span class="mt-2 text-gray-700 font-medium">Assistant</span> -->
    </div>
  </div>
  
  <button id="stop-btn" class="bg-red-500 text-white py-1 px-3 rounded-md hover:bg-red-600 transition-colors">Stop Call</button>
  <div id="call-summary" class="mt-4 text-sm text-gray-600"></div>
</div>


        <!-- Chat Container (hidden by default) -->
        <!-- Chat Container (hidden by default) -->
<div id="chat-container" class="hidden max-w-3xl mx-auto my-8 p-6 bg-white rounded-lg shadow-lg">
  <!-- New heading element for survey heading in chat -->
  <h2 id="chat-heading" class="text-xl font-semibold text-gray-700 mb-4">Chat Interface</h2>
  <div id="chat-messages" class="mb-4 overflow-auto max-h-64">
    <!-- Initial message will be inserted here -->
  </div>
  <div class="flex space-x-4">
    <input type="text" id="chat-input" class="flex-1 p-2 border rounded-md" placeholder="Type your question..." />
    <button id="chat-send-btn" class="bg-green-500 hover:bg-green-600 text-white font-semibold rounded-md px-4 py-2 transition-colors">
      Send
    </button>
  </div>
  <div class="mt-4 flex justify-between items-center">
    <a href="#" id="back-to-voice" class="text-blue-500 hover:underline">Back to Voice AI</a>
    <!-- New Stop Survey button -->
    <button id="stop-survey-btn" class="bg-red-500 hover:bg-red-600 text-white font-semibold rounded-md px-4 py-2 transition-colors">
      Stop Survey
    </button>
  </div>
</div>

      </div>
    </div>

    <!-- VAPI SDK Script -->
    <script>
      var vapiInstance = null;
      const assistant = "5e7d3a07-f7d5-4975-8bd8-2c32ae092f01";
      const apiKey = "c2e5d26a-941f-42c7-8bf4-02ebc2844242";


      (function (d, t) {
        var g = document.createElement(t),
          s = d.getElementsByTagName(t)[0];
        g.src =
          "https://cdn.jsdelivr.net/gh/VapiAI/html-script-tag@latest/dist/assets/index.js";
        g.defer = true;
        g.async = true;
        s.parentNode.insertBefore(g, s);

        g.onload = function () {
          vapiInstance = window.vapiSDK.run({
            apiKey: apiKey,
            assistant: assistant,
          });

          vapiInstance.on("speech-start", () => {
            document.getElementById("assistant-status").textContent =
              "Assistant Status: Speaking";
          });
          vapiInstance.on("speech-end", () => {
            document.getElementById("assistant-status").textContent =
              "Assistant Status: Not Speaking";
          });
          vapiInstance.on("volume-level", (level) => {
  const aiRipple = document.getElementById("ai-avatar-ripple");
  if (aiRipple) {
    // Adjust scale for a bigger ripple effect
    const scale = 1 + level * 0.8;
    const opacity = level; 
    aiRipple.style.transform = `scale(${scale})`;
    aiRipple.style.opacity = opacity;
  }
});

        };
      })(document, "script");

      let globalCallId = null;
      // Use separate variables for history record and chat record IDs.
      window.latestRecordId = null;
      window.latestChatRecordId = null;
      window.latestRawTranscript = null;
      window.currentSurvey = null;    // Will store the survey data
      window.isEditMode = false; 

      //       if (!window.chatRecordCounter) {
      //   window.chatRecordCounter = 1;
      // }
      // if (!localStorage.getItem("chatRecordCounter")) {
      //   localStorage.setItem("chatRecordCounter", "1");
      // }

      // Start the assistant call using the Web SDK

      var callTimerInterval;
var callStartTime;

function startCallTimer() {
  callStartTime = Date.now();
  document.getElementById("call-timer").textContent = "00:00";
  callTimerInterval = setInterval(() => {
    const elapsed = Date.now() - callStartTime;
    const totalSeconds = Math.floor(elapsed / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    // Format minutes and seconds as two digits
    document.getElementById("call-timer").textContent =
      `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  }, 1000);
}

function stopCallTimer() {
  clearInterval(callTimerInterval);
}

      function startWebCall(extractedText) {
        const accentValue = document.getElementById("accent").value;
        const extrasValue = document.getElementById("extras").value;
        const toneValue = document.getElementById("tone").value;
        let voiceConfig = {};
        switch (accentValue) {
          case "indian_lady":
            voiceConfig = {
              provider: "cartesia",
              voiceId: "3b554273-4299-48b9-9aaf-eefd438e3941",
            };
            break;
          case "indian_man":
            voiceConfig = {
              provider: "cartesia",
              voiceId: "638efaaa-4d0c-442e-b701-3fae16aad012",
            };
            break;
          case "british_lady":
            voiceConfig = {
              provider: "cartesia",
              voiceId: "79a125e8-cd45-4c13-8a67-188112f4dd22",
            };
            break;
          case "anime_girl":
            voiceConfig = {
              provider: "cartesia",
              voiceId: "1001d611-b1a8-46bd-a5ca-551b23505334",
            };
            break;
          case "british_man":
            voiceConfig = {
              provider: "cartesia",
              voiceId: "63ff761f-c1e8-414b-b969-d1833d1c870c",
            };
            break;
          case "middle_east_women":
            voiceConfig = {
              provider: "cartesia",
              voiceId: "daf747c6-6bc2-4083-bd59-aa94dce23f5d",
            };
            break;
          case "australian_women":
            voiceConfig = {
              provider: "cartesia",
              voiceId: "043cfc81-d69f-4bee-ae1e-7862cb358650",
            };
            break;
          case "california_girl":
            voiceConfig = { provider: "cartesia", voiceId: "b7d50908-b17c-442d-ad8d-810c63997ed9" };
            break;
          case "new_york_man":
            voiceConfig = { provider: "cartesia", voiceId: "34575e71-908f-4ab6-ab54-b08c95d6597d" };
            break;
          case "new_york_women":
            voiceConfig = { provider: "cartesia", voiceId: "34bde396-9fde-4ebf-ad03-e3a1d1155205" };
            break;
          case "savannah":
            voiceConfig = { provider: "vapi", voiceId: "Savannah" };
            break;
          case "kentucky_man":
            voiceConfig = { provider: "cartesia", voiceId: "726d5ae5-055f-4c3d-8355-d9677de68937" };
            break;
          case "kentucky_woman":
            voiceConfig = { provider: "cartesia", voiceId: "4f8651b0-bbbd-46ac-8b37-5168c5923303" };
            break;
          case "sesame":
            voiceConfig = { provider: "cartesia", voiceId: "4f8651b0-bbbd-46ac-8b37-5168c5923303" };
            break;
          default:
            voiceConfig = {
              provider: "sesame",
              voiceId: "default",
            };
            break;
        }
        if (extrasValue !== "none") {
          voiceConfig.experimentalControls = {
            emotion: [`${extrasValue}:highest`],
          };
        }
        console.log(toneValue);
        const assistantOverrides = {
          startSpeakingPlan: {
    waitSeconds: 1.4, // Set this to your desired wait time
  },
          firstMessageMode: "assistant-speaks-first",
          model: {
            provider: "openai",
            model: "gpt-4",
            messages: [
              {
                role: "system",
                content: ` Please start by asking for the employee ID. Once the user provides an ID, confirm it by repeating it back and asking if it is correct.
If the provided employee ID is valid, give a short, dynamic introduction about the survey based on the survey content below and tell that all of their responses will strictly confidential, then proceed with a structured, question-by-question survey flow. Keep the tone ${toneValue} and non-intrusive. Ensure that the conversation flows naturally and dynamically rather than presenting questions as a rigid list. The AI should integrate pre-configured questions fluidlyâ€”adapting to context. Encourage honest responses without pressure.

Flow of Questions:
${extractedText}
make the questions strictly in a long conversational manner rather than just saying what the actual question is. You can change it to appear more conversational, even expand the question if it's too short, as if talking to a friend or co-worker. Avoid directly asking the question; guide the user towards thoughtful answers. If options are present, do not list them unless asked for.
Stay on Topic: The conversation must remain strictly within the scope of the survey.
If unrelated topics are introduced, respond with:
"I'm here to assist with the survey. Let's stay focused on the questions."
If persistence occurs, respond with:
"Iâ€™m sorry, but I can only respond to questions related to the survey."
If the answer is not satisfactory, include a follow-up like: "What did you find challenging about that?"
Open Feedback:
"Is there anything else you'd like to add or clarify?"
Closing:
"Thank you! We will carefully review your input and make improvements. If you think of anything else, feel free to share!"`,
              },
            ],
          },
          summaryPrompt:
            'You will be given a transcript of a call. Extract key information, including the employee ID  and the userâ€™s tone, and structure it into a concise JSON-like format. For example:\n\n{\n  "employee_id": "",\n  "summary": "",\n  "ratings": {\n    "TopicA": { "rating": 5, "comment": "" },\n    "TopicB": { "rating": 2, "comment": "" }\n  },\n  "overall": "",\n  "next_steps": ""\n}',
          voice: voiceConfig,
        };
        return vapiInstance
          .start(assistant, assistantOverrides)
          .then((response) => {
            console.log("VAPI Web call started:", response);
            globalCallId = response.id;
            startCallTimer();
            return response;
          })
          .catch((error) => {
            console.error("Error starting web call:", error);
          });
      }

      function stopWebCall() {
        vapiInstance.stop();
        stopCallTimer();

        const userRipple = document.getElementById("user-avatar-ripple");
  if (userRipple) {
    userRipple.style.opacity = 0;
    userRipple.style.transform = "scale(1)";
  }
  
  const aiRipple = document.getElementById("ai-avatar-ripple");
  if (aiRipple) {
    aiRipple.style.opacity = 0;
    aiRipple.style.transform = "scale(1)";
  }


        document.getElementById("call-summary").innerHTML =
    '<p class="text-gray-600">Summary loading...</p>';
        setTimeout(() => {
          pollCallDetails(globalCallId);
        }, 1000);
      }

      function pollCallDetails(callId, interval = 3000) {
        fetch("/call-details?call_id=" + callId, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: "Bearer " + apiKey,
          },
          body: JSON.stringify({ record_id: window.latestRecordId })
        })
          .then((response) => {
            if (!response.ok) {
              console.error(
                "Error fetching call details:",
                response.status,
                response.statusText
              );
              if (response.status === 403) {
                document.getElementById("call-summary").innerHTML =
                  "<h3>Error:</h3><p>Access forbidden. Check credentials.</p>";
              }
              throw new Error("HTTP error " + response.status);
            }
            return response.json();
          })
          .then((data) => {
            if (data.error) {
              console.error("Error in call details response:", data.error);
              return;
            }
            if (data.summary) {
              document.getElementById("call-summary").innerHTML =
                "<h3 class='font-semibold mb-2'>Call Summary</h3><p>" +
                data.summary +
                "</p>";
              // Once summary is available, show the Chat with Survey button
              let chatBtn = document.getElementById("chat-survey-btn");
              if (chatBtn) {
                chatBtn.classList.remove("hidden");
              }
            } else {
              console.log(
                "Summary not yet available; retrying in",
                interval,
                "ms"
              );
              setTimeout(() => pollCallDetails(callId, interval), interval);
            }
          })
          .catch((err) => {
            console.error("Error polling call details:", err);
          });
      }

      // PDF Upload & Extraction
      document
        .getElementById("upload-btn")
        .addEventListener("click", function () {
          const fileInput = document.getElementById("pdf-file");
          const file = fileInput.files[0];
          const statusEl = document.getElementById("upload-status");
          if (!file) {
            alert("Please select a PDF file.");
            return;
          }
          const formData = new FormData();
          formData.append("file", file);
          statusEl.textContent = "Uploading and extracting PDF...";
          fetch("/extract", {
            method: "POST",
            headers: { Authorization: "Bearer " + apiKey },
            body: formData,
          })
            .then((response) => response.json())
            .then((data) => {
              if (data.error) {
                statusEl.textContent = "Error: " + data.error;
                return;
              }
              statusEl.textContent = "Extraction complete.";
              const extractedText = data.text;
              document.getElementById("pdf-upload-section").style.display =
                "none";
              document.getElementById("call-section").style.display = "block";
              fetch("/start-call", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: "Bearer " + apiKey,
                },
                body: JSON.stringify({ text: extractedText }),
              })
                .then((response) => response.json())
                .then((callData) => {
                  if (callData.error) {
                    statusEl.textContent =
                      "Call start error: " + callData.error;
                    return;
                  }
                  const callId = callData.call_id;
                  pollCallDetails(callId);
                });
              startWebCall(extractedText);
            })
            .catch((err) => {
              statusEl.textContent = "Error during upload: " + err;
            });
        });

      

      // In the survey submission event listener, replace the assignment for window.latestChatRecordId:
//       document.getElementById("survey-submit-btn").addEventListener("click", function () {
//   const promptText = document.getElementById("survey-prompt").value;
//   const surveyLength = document.getElementById("survey-length").value;
//   const responseBox = document.getElementById("survey-response");
//   if (!promptText) {
//     alert("Please enter a survey prompt.");
//     return;
//   }
//   responseBox.value = "Waiting for response...";
//   fetch("/groq-chat", {
//     method: "POST",
//     headers: { "Content-Type": "application/json" },
//     body: JSON.stringify({
//       prompt: promptText,
//       survey_length: surveyLength,
//     }),
//   })
//     .then((response) => response.json())
//     .then((data) => {
//       if (data.error) {
//         responseBox.value = "Error: " + data.error;
//       } else {
//         responseBox.value = data.response;
//         // Update the Call Section heading with the survey heading.
//         document.getElementById("call-heading").textContent = `Call in Progress: ${data.survey_heading}`;
//         // Update the Chat Container heading with the survey heading.
//         document.getElementById("chat-heading").textContent = data.survey_heading;
//         // Store the history record id as a number.
//         window.latestRecordId = parseInt(data.record_id);
//         // Get the current chat record counter from localStorage.
//         let counter = parseInt(localStorage.getItem("chatRecordCounter"));
//         window.latestChatRecordId = counter; // Use this as the chat record id.
//         // Increment and store back to localStorage for next chat record.
//         localStorage.setItem("chatRecordCounter", (counter + 1).toString());
//         // Show Chat with Survey button if call summary is available.
//         let chatBtn = document.getElementById("chat-survey-btn");
//         if (chatBtn) {
//           chatBtn.classList.remove("hidden");
//         }
//       }
//     })
//     .catch((err) => {
//       responseBox.value = "Error: " + err;
//     });
// });
// 1) SURVEY SUBMIT BUTTON EVENT
document.getElementById("survey-submit-btn").addEventListener("click", () => {
        const surveyContainer = document.getElementById("survey-response");
        const promptText = document.getElementById("survey-prompt").value;
        const surveyLength = document.getElementById("survey-length").value;

        if (!promptText) {
          alert("Please enter a survey prompt.");
          return;
        }

        surveyContainer.innerHTML = '<p class="text-gray-600 mb-4">Loading survey...</p>';

        fetch("/groq-chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ prompt: promptText, survey_length: surveyLength }),
        })
          .then(response => response.json())
          .then(data => {
            if (data && data.survey) {
             // Directly assign the record_id from the server (a UUID string) to latestRecordId.
window.latestRecordId = data.record_id;
// Use the same UUID for chat record since we're now treating IDs as UUID strings.
window.latestChatRecordId = data.chatRecordId;
window.publicSurveyId=data.public_survey_id
                document.getElementById("call-heading").textContent = `Call in Progress: ${data.survey.survey_title}`; // Update the Chat Container heading with the survey heading. 
              document.getElementById("chat-heading").textContent = data.survey.survey_title;
              window.currentSurvey = data.survey;
              renderPreviewSurvey(window.currentSurvey, surveyContainer);
            } else {
              surveyContainer.innerHTML = '<p class="text-red-600">Survey data not found.</p>';
            }
          })
          .catch(error => {
            console.error("Error fetching survey data:", error);
            surveyContainer.innerHTML = '<p class="text-red-600">Error loading survey.</p>';
          });
      });



// Function to render an editable survey heading.
function renderEditableHeading(surveyData, container) {
  // Create a container for the heading and its edit controls.
  const headingContainer = document.createElement("div");
  headingContainer.className = "relative mb-6";

  // Create the heading element for preview mode.
  const headingEl = document.createElement("h2");
  headingEl.textContent = surveyData.survey_title;
  headingEl.className = "text-2xl font-bold";
  headingContainer.appendChild(headingEl);

  // Create the edit icon button (âœŽ) positioned at the top-right.
  const editIcon = document.createElement("button");
  editIcon.innerHTML = "&#9998;"; // âœŽ icon
  editIcon.className = "absolute top-0 right-0 text-blue-500";
  headingContainer.appendChild(editIcon);

  // When the edit icon is clicked, switch to edit mode.
  editIcon.addEventListener("click", () => {
    // Clear the heading container.
    headingContainer.innerHTML = "";

    // Create an input field pre-filled with the current heading.
    const inputField = document.createElement("input");
    inputField.type = "text";
    inputField.value = surveyData.survey_title;
    inputField.className = "text-2xl font-bold p-2 border rounded w-full";
    headingContainer.appendChild(inputField);

    // Create the "Save" button.
    const saveBtn = document.createElement("button");
    saveBtn.textContent = "Save";
    saveBtn.className = "absolute top-2 right-2 bg-blue-500 text-white px-3 py-1 rounded";
    headingContainer.appendChild(saveBtn);

    // Save the new heading and revert to preview mode when "Save" is clicked.
    saveBtn.addEventListener("click", () => {
      const newHeading = inputField.value.trim();
      if (newHeading !== "") {
        surveyData.survey_title = newHeading;
      }
      // Re-render preview mode.
      headingContainer.innerHTML = "";
      headingEl.textContent = surveyData.survey_title;
      headingContainer.appendChild(headingEl);
      headingContainer.appendChild(editIcon);
    });
  });

  // Append the editable heading container to the provided container.
  container.appendChild(headingContainer);
}

// Render an editable section for "intro" or "outro" (using a paragraph tag).
function renderEditableSection(fieldName, surveyData, container, tagName, extraClass) {
  // Make the top-level container a flex row (so text is on the left, icon on the right).
  const sectionContainer = document.createElement("div");
  sectionContainer.className = "flex justify-between items-start mb-4";

  // Put your text in a separate div to allow multiline text to wrap nicely.
  const textWrapper = document.createElement("div");
  const sectionEl = document.createElement(tagName);
  sectionEl.textContent = surveyData[fieldName];
  sectionEl.className = extraClass || "";
  textWrapper.appendChild(sectionEl);

  // Create your edit icon, but remove all absolute positioning.
  const editIcon = document.createElement("button");
  editIcon.innerHTML = "&#9998;"; // âœŽ icon
  editIcon.className = "text-blue-500 hover:text-blue-600 px-2";

  // Append both textWrapper and editIcon to the sectionContainer.
  sectionContainer.appendChild(textWrapper);
  sectionContainer.appendChild(editIcon);

  // When edit is clicked, swap to the textarea version:
  editIcon.addEventListener("click", () => {
    // Clear the container first
    sectionContainer.innerHTML = "";

    // Rebuild as a column for editing
    sectionContainer.className = "mb-4"; // e.g., no flex while editing
    const textarea = document.createElement("textarea");
    textarea.value = surveyData[fieldName];
    textarea.className = "w-full p-2 border rounded";
    sectionContainer.appendChild(textarea);

    // Add a save button below the textarea
    const buttonContainer = document.createElement("div");
    buttonContainer.className = "mt-2";
    const saveBtn = document.createElement("button");
    saveBtn.textContent = "Save";
    saveBtn.className = "bg-blue-500 text-white px-3 py-1 rounded";
    buttonContainer.appendChild(saveBtn);
    sectionContainer.appendChild(buttonContainer);

    // Save logic
    saveBtn.addEventListener("click", () => {
      const newText = textarea.value.trim();
      if (newText !== "") {
        surveyData[fieldName] = newText;
      }
      // Re-render the preview mode
      sectionContainer.innerHTML = "";
      sectionContainer.className = "flex justify-between items-start mb-4";
      textWrapper.innerHTML = "";
      sectionEl.textContent = surveyData[fieldName];
      textWrapper.appendChild(sectionEl);
      sectionContainer.appendChild(textWrapper);
      sectionContainer.appendChild(editIcon);
    });
  });

  container.appendChild(sectionContainer);
}

// -----------------------------
// RENDERING FUNCTIONS
// -----------------------------

// Update the renderPreviewSurvey function to append the "Add Question" button and form container
function renderPreviewSurvey(surveyData, container) {
  container.innerHTML = "";
  // Render the editable survey heading.
  renderEditableHeading(surveyData, container);

  // Render the editable Intro.
  renderEditableSection("intro", surveyData, container, "p", "text-base text-gray-700");

  // Render each question with inline edit capability
  surveyData.questions.forEach(question => {
    // Ensure each question has an "editMode" property (default false)
    if (question.editMode === undefined) {
      question.editMode = false;
    }
    const questionElem = renderQuestion(question);
    container.appendChild(questionElem);
  });

  // "Add Question" button
  const addQuestionBtn = document.createElement("button");
  addQuestionBtn.textContent = "Add Question";
  addQuestionBtn.className = "bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 mt-4";
  container.appendChild(addQuestionBtn);

  // Container for the add question form (hidden by default)
  const addQuestionFormContainer = document.createElement("div");
  addQuestionFormContainer.className = "mt-4 p-4 border rounded bg-gray-100";
  addQuestionFormContainer.style.display = "none"; // hidden initially
  container.appendChild(addQuestionFormContainer);

  // When the add question button is clicked, show the form
  addQuestionBtn.addEventListener("click", () => {
    addQuestionFormContainer.style.display = "block";
    renderAddQuestionForm(surveyData, addQuestionFormContainer, container);
  });
  // Add a spacer element for extra spacing
  const spacer = document.createElement("div");
  spacer.className = "mt-6"; // Adjust this class for more/less spacing
  container.appendChild(spacer);

  // Render the editable Outro.
  renderEditableSection("outro", surveyData, container, "p", "text-base text-gray-700");
}

// Render the inline Add Question form
function renderAddQuestionForm(surveyData, formContainer, surveyContainer) {
  formContainer.innerHTML = ""; // clear any previous content

  // Question Title Input
  const titleLabel = document.createElement("label");
  titleLabel.textContent = "Question Title:";
  titleLabel.className = "block text-sm font-medium text-gray-700";
  formContainer.appendChild(titleLabel);
  const titleInput = document.createElement("input");
  titleInput.type = "text";
  titleInput.className = "w-full p-2 border rounded mt-1 mb-4";
  formContainer.appendChild(titleInput);

  // Question Type Dropdown
  const typeLabel = document.createElement("label");
  typeLabel.textContent = "Question Type:";
  typeLabel.className = "block text-sm font-medium text-gray-700";
  formContainer.appendChild(typeLabel);
  const typeSelect = document.createElement("select");
  typeSelect.className = "w-full p-2 border rounded mt-1 mb-4";
  const types = ["multiple_choice", "short_answer", "paragraph", "rating"];
  types.forEach(t => {
    const option = document.createElement("option");
    option.value = t;
    // Display with spaces and uppercase for readability
    option.textContent = t;
    typeSelect.appendChild(option);
  });
  formContainer.appendChild(typeSelect);

  // Container for options inputs (only visible for multiple_choice or rating)
  const optionsContainer = document.createElement("div");
  optionsContainer.style.display = "none";
  formContainer.appendChild(optionsContainer);

  // Function to render the options input fields
  function renderOptionsInputs() {
    optionsContainer.innerHTML = "";

    // Create the "Add Option" button
    const addOptionBtn = document.createElement("button");
    addOptionBtn.textContent = "Add Option";
    addOptionBtn.className = "bg-blue-500 text-white px-3 py-1 rounded mt-2";
    addOptionBtn.type = "button";

    // Append the button to the container first
    optionsContainer.appendChild(addOptionBtn);

    // Helper: how many options currently in the container?
    function getCurrentOptionCount() {
      return optionsContainer.querySelectorAll("div.flex.items-center").length;
    }

    // Function to add an option input field
    function addOptionInput(value = "") {
      // If no value given, label it "Option X" based on the current count
      if (!value) {
        const nextIndex = getCurrentOptionCount() + 1;
        value = `Option ${nextIndex}`;
      }

      // Create a row for the option
      const optionDiv = document.createElement("div");
      optionDiv.className = "flex items-center mt-2";

      // The text input for the option
      const optionInput = document.createElement("input");
      optionInput.type = "text";
      optionInput.value = value;
      optionInput.className = "flex-1 p-2 border rounded";
      optionDiv.appendChild(optionInput);

      // Remove button
      const removeBtn = document.createElement("button");
      removeBtn.textContent = "X";
      removeBtn.className = "bg-red-500 text-white px-2 py-1 rounded ml-2";
      removeBtn.type = "button";
      removeBtn.addEventListener("click", () => {
        optionDiv.remove();
      });
      optionDiv.appendChild(removeBtn);

      // Insert the new option above the "Add Option" button
      optionsContainer.insertBefore(optionDiv, addOptionBtn);
    }

    // Add an initial option field
    addOptionInput();

    // Each time "Add Option" is clicked, re-check the count
    addOptionBtn.addEventListener("click", () => {
      addOptionInput();
    });
  }

  // Toggle options container visibility based on selected question type
  typeSelect.addEventListener("change", () => {
    if (typeSelect.value === "multiple_choice" || typeSelect.value === "rating") {
      optionsContainer.style.display = "block";
      renderOptionsInputs();
    } else {
      optionsContainer.style.display = "none";
    }
  });
  // Trigger change to initialize the proper state
  typeSelect.dispatchEvent(new Event("change"));

  // "Done" button to save the new question and close the form
  const doneBtn = document.createElement("button");
  doneBtn.textContent = "Done";
  doneBtn.className = "bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 mt-4";
  doneBtn.type = "button";
  formContainer.appendChild(doneBtn);

  doneBtn.addEventListener("click", () => {
    // Validate question title input
    if (!titleInput.value.trim()) {
      alert("Please enter a question title.");
      return;
    }
    // Gather option values if applicable
    let options = [];
    if (typeSelect.value === "multiple_choice" || typeSelect.value === "rating") {
      const optionInputs = optionsContainer.querySelectorAll("input[type='text']");
      optionInputs.forEach(input => {
        if (input.value.trim()) {
          options.push(input.value.trim());
        }
      });
      if (options.length === 0) {
        alert("Please add at least one option.");
        return;
      }
    }
    // Create a new question object
    const newQuestion = {
      id: Date.now(), // use timestamp as a unique id
      question: titleInput.value.trim(),
      type: typeSelect.value,
      options: options,
      answer: "",
      editMode: false
    };

    // Update the surveyData.questions array
    surveyData.questions.push(newQuestion);

    // Re-render the survey form to include the new question and hide the form
    renderPreviewSurvey(surveyData, surveyContainer);
  });
}

// Main render function for a question.
// It will call either the preview or edit renderer based on question.editMode.
function renderQuestion(question) {
  return question.editMode ? renderQuestionEdit(question) : renderQuestionPreview(question);
}

// Render a question in Preview Mode (read-only for structure, but answer inputs are now disabled)
function renderQuestionPreview(question) {
  const container = document.createElement("div");
  container.className = "relative border p-4 rounded-lg bg-gray-50 mb-4";

  // Header: Question text and inline Edit button (ðŸ–Šï¸)
  const headerDiv = document.createElement("div");
  headerDiv.className = "flex justify-between items-center";
  const questionText = document.createElement("p");
  questionText.textContent = question.question;
  questionText.className = "font-semibold text-gray-800";
  headerDiv.appendChild(questionText);
  const editBtn = document.createElement("button");
  editBtn.innerHTML = "&#9998;"; // ðŸ–Šï¸ icon
  editBtn.className = "text-blue-500";
  editBtn.addEventListener("click", () => {
    question.editMode = true;
    container.replaceWith(renderQuestion(question));
  });
  headerDiv.appendChild(editBtn);
  container.appendChild(headerDiv);

  // Render answer input based on question type (all inputs are disabled)
  if (question.type === "multiple_choice") {
    question.options.forEach(opt => {
      const optDiv = document.createElement("div");
      optDiv.className = "flex items-center mt-2";
      const radio = document.createElement("input");
      radio.type = "radio";
      radio.name = "question_" + question.id;
      radio.value = opt;
      radio.className = "mr-2 w-auto";
      radio.disabled = true; // disable input
      const label = document.createElement("label");
      label.textContent = opt;
      optDiv.appendChild(radio);
      optDiv.appendChild(label);
      container.appendChild(optDiv);
    });
  } else if (question.type === "short_answer") {
    const input = document.createElement("input");
    input.type = "text";
    input.placeholder = "Your answer...";
    input.className = "w-full p-2 border rounded mt-2";
    input.disabled = true; // disable input
    container.appendChild(input);
  } else if (question.type === "rating") {
    if (question.options && question.options.length > 0) {
      const selectEl = document.createElement("select");
      selectEl.className = "w-full p-2 border rounded mt-2";
      selectEl.disabled = true; // disable select
      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "Select rating";
      selectEl.appendChild(placeholder);
      question.options.forEach(opt => {
        const optionEl = document.createElement("option");
        optionEl.value = opt;
        optionEl.textContent = opt;
        selectEl.appendChild(optionEl);
      });
      container.appendChild(selectEl);
    } else {
      const ratingDiv = document.createElement("div");
      ratingDiv.className = "flex space-x-2 mt-2";
      for (let i = 1; i <= 5; i++) {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = i;
        btn.className = "px-3 py-1 border rounded";
        btn.disabled = true; // disable button
        ratingDiv.appendChild(btn);
      }
      container.appendChild(ratingDiv);
    }
  } else if (question.type === "paragraph") {
    const textarea = document.createElement("textarea");
    textarea.rows = 3;
    textarea.placeholder = "Your answer...";
    textarea.className = "w-full p-2 border rounded mt-2";
    textarea.disabled = true; // disable textarea
    container.appendChild(textarea);
  }

  return container;
}

// Render a single question in Edit Mode (inline editing)
function renderQuestionEdit(question) {
  const container = document.createElement("div");
  container.className = "relative border p-4 rounded-lg bg-gray-50 mb-4";

  // Editable Question Text
  const labelText = document.createElement("label");
  labelText.textContent = "Question:";
  labelText.className = "block font-semibold text-gray-800 mb-1";
  container.appendChild(labelText);
  const inputText = document.createElement("input");
  inputText.type = "text";
  inputText.value = question.question;
  inputText.className = "w-full p-2 border rounded mb-2";
  inputText.addEventListener("input", () => {
    question.question = inputText.value;
  });
  container.appendChild(inputText);

  // Editable Question Type Dropdown
  const labelType = document.createElement("label");
  labelType.textContent = "Type:";
  labelType.className = "block font-semibold text-gray-800 mb-1";
  container.appendChild(labelType);
  const selectType = document.createElement("select");
  selectType.className = "w-full p-2 border rounded mb-2";
  ["multiple_choice", "short_answer", "rating", "paragraph"].forEach(t => {
    const opt = document.createElement("option");
    opt.value = t;
    opt.textContent = t;
    if (t === question.type) opt.selected = true;
    selectType.appendChild(opt);
  });
  selectType.addEventListener("change", () => {
    const oldType = question.type;
    question.type = selectType.value;
    // When switching to an option-based type from text-based, prompt for options.
    if ((oldType === "paragraph" || oldType === "short_answer") &&
        (question.type === "multiple_choice" || question.type === "rating")) {
      if (confirm("Switched to an option-based question. Add options now?")) {
        const numOptions = parseInt(prompt("How many options?", "2"), 10);
        if (!isNaN(numOptions) && numOptions > 0) {
          question.options = [];
          for (let i = 0; i < numOptions; i++) {
            question.options.push(`Option ${i + 1}`);
          }
        } else {
          question.options = [];
        }
      } else {
        question.options = [];
      }
    } else if ((oldType === "multiple_choice" || oldType === "rating") &&
               (question.type === "paragraph" || question.type === "short_answer")) {
      question.options = [];
    }
    renderOptionsEdit(question, optionsContainer);
  });
  container.appendChild(selectType);

  // Container for editing options (if applicable)
  const optionsContainer = document.createElement("div");
  optionsContainer.className = "mb-2";
  container.appendChild(optionsContainer);

  // Function to render options edit interface
  function renderOptionsEdit(question, container) {
    container.innerHTML = "";
    if (question.type === "multiple_choice" || question.type === "rating") {
      if (!Array.isArray(question.options)) {
        question.options = [];
      }
      question.options.forEach((opt, idx) => {
        const row = document.createElement("div");
        row.className = "flex items-center mb-1";
        const optInput = document.createElement("input");
        optInput.type = "text";
        optInput.value = opt;
        optInput.className = "flex-1 p-1 border rounded mr-2";
        optInput.addEventListener("input", () => {
          question.options[idx] = optInput.value;
        });
        const removeBtn = document.createElement("button");
        removeBtn.textContent = "X";
        removeBtn.className = "bg-red-500 text-white px-2 rounded";
        removeBtn.addEventListener("click", () => {
          question.options.splice(idx, 1);
          renderOptionsEdit(question, container);
        });
        row.appendChild(optInput);
        row.appendChild(removeBtn);
        container.appendChild(row);
      });
      const addBtn = document.createElement("button");
      addBtn.textContent = "Add Option";
      addBtn.className = "bg-green-500 text-white px-2 py-1 rounded";
      addBtn.addEventListener("click", () => {
        question.options.push("New Option");
        renderOptionsEdit(question, container);
      });
      container.appendChild(addBtn);
    }
  }
  renderOptionsEdit(question, optionsContainer);

  // // Answer input (editable as in preview but now disabled)
  // const labelAnswer = document.createElement("label");
  // labelAnswer.textContent = "Answer:";
  // labelAnswer.className = "block font-semibold text-gray-700 mb-1";
  // container.appendChild(labelAnswer);
  // let answerInput;
  // if (question.type === "multiple_choice" || question.type === "rating") {
  //   answerInput = document.createElement("select");
  //   answerInput.className = "w-full p-2 border rounded mb-2";
  //   answerInput.disabled = true; // disable select
  //   const defaultOpt = document.createElement("option");
  //   defaultOpt.value = "";
  //   defaultOpt.textContent = "Select an answer";
  //   answerInput.appendChild(defaultOpt);
  //   if (Array.isArray(question.options)) {
  //     question.options.forEach(opt => {
  //       const optEl = document.createElement("option");
  //       optEl.value = opt;
  //       optEl.textContent = opt;
  //       if (question.answer === opt) optEl.selected = true;
  //       answerInput.appendChild(optEl);
  //     });
  //   }
  // } else {
  //   if (question.type === "paragraph") {
  //     answerInput = document.createElement("textarea");
  //     answerInput.rows = 3;
  //   } else {
  //     answerInput = document.createElement("input");
  //     answerInput.type = "text";
  //   }
  //   answerInput.value = question.answer || "";
  //   answerInput.className = "w-full p-2 border rounded mb-2";
  //   answerInput.disabled = true; // disable input/textarea
  // }
  // answerInput.addEventListener("input", () => {
  //   question.answer = answerInput.value;
  // });
  // container.appendChild(answerInput);

  // Save button to exit edit mode (positioned at top-right)
  const saveBtn = document.createElement("button");
  saveBtn.textContent = "Save";
  saveBtn.className = "bg-blue-500 text-white px-3 py-1 rounded absolute top-2 right-2";
  saveBtn.addEventListener("click", () => {
    question.editMode = false;
    container.replaceWith(renderQuestion(question));
  });
  container.appendChild(saveBtn);

  return container;
}


      // Send Survey Response to Voice AI
      document
        .getElementById("send-voice-btn")
        .addEventListener("click", function () {
          const responseText = document.getElementById("survey-response").textContent;
          if (!responseText) {
            alert("No response text available to send.");
            return;
          }
          // Hide chat container if visible.
          document.getElementById("chat-container").classList.add("hidden");
          // Ensure the Voice AI container is visible.
          document.getElementById("call-section").classList.remove("hidden");
              setupUserAvatarVolumeVisualizer();

          fetch("/start-call", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: "Bearer " + apiKey,
            },
            body: JSON.stringify({ text: responseText }),
          })
            .then((response) => response.json())
            .then((callData) => {
              if (callData.error) {
                return;
              }
              const callId = callData.call_id;
              pollCallDetails(callId);
            });
          startWebCall(responseText);
          setTimeout(() => {
            document
              .getElementById("call-section")
              .scrollIntoView({ behavior: "smooth" });
          }, 300);
        });

      // Stop call
      document
        .getElementById("stop-btn")
        .addEventListener("click", function () {
          stopWebCall();
        });

      // Chat with Survey button functionality: Hide call section and show chat container.
      document
        .getElementById("chat-survey-btn")
        .addEventListener("click", function () {
          document.getElementById("call-section").classList.add("hidden");
          document.getElementById("chat-container").classList.remove("hidden");
          let data = document.getElementById("survey-response").textContent;
          const chatMessages = document.getElementById("chat-messages");
          // Start with an initial greeting and include the chat record id in the context if needed.
          chatMessages.innerHTML =
            "<p class='text-green-600 font-semibold'>Bot: Hi, let's start the survey. Are you ready?</p>";
            document.getElementById("chat-container").scrollIntoView({ behavior: "smooth" });

        });

      // Back to Voice AI link in chat container
      document
        .getElementById("back-to-voice")
        .addEventListener("click", function (e) {
          e.preventDefault();
          document.getElementById("chat-container").classList.add("hidden");
          document.getElementById("call-section").classList.remove("hidden");
        });

      // Chat send functionality for the Chat with Survey interface.
      document.addEventListener("DOMContentLoaded", function () {
        document
          .getElementById("chat-send-btn")
          .addEventListener("click", function () {
            const chatInput = document.getElementById("chat-input");
            const question = chatInput.value.trim();
            if (!question) return;
            const chatMessages = document.getElementById("chat-messages");

            // Append the user's message.
            const userMsg = document.createElement("div");
            userMsg.textContent = "You: " + question;
            userMsg.className = "text-blue-600 font-semibold my-1";
            chatMessages.appendChild(userMsg);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            const surveyResponseText =
              document.getElementById("survey-response").textContent;
            // Use the latest raw transcript as context.
            const rawTranscript = window.latestRawTranscript || "";
            fetch("/chat_with_survey", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                question: question,
                survey_response: surveyResponseText,
                record_id: window.latestChatRecordId,
              }),
            })
              .then((response) => response.json())
              .then((data) => {
                const botMsg = document.createElement("div");
                if (data.error) {
                  botMsg.textContent = "Error: " + data.error;
                  botMsg.className = "text-red-600 font-semibold my-1";
                } else {
                  botMsg.textContent = "Bot: " + data.response;
                  botMsg.className = "text-green-600 font-semibold my-1";
                  // Optionally update the latest raw transcript with the new context.
                  window.latestRawTranscript += "\n" + data.response;
                }
                chatMessages.appendChild(botMsg);
                chatMessages.scrollTop = chatMessages.scrollHeight;
              })
              .catch((error) => {
                const errorEl = document.createElement("div");
                errorEl.textContent = "Error: " + error;
                errorEl.className = "text-red-600 font-semibold my-1";
                chatMessages.appendChild(errorEl);
              });
            chatInput.value = "";
          });
      });

      // Prefill fields if URL has parameters.
      document.addEventListener("DOMContentLoaded", function () {
        const params = new URLSearchParams(window.location.search);
        const prompt = params.get("prompt");
        const promptSummary = params.get("prompt_summary");
        if (prompt) {
          document.getElementById("survey-prompt").value = prompt;
        }
        if (promptSummary) {
          document.getElementById("survey-response").value = promptSummary;
        }
      });
      // Stop Survey button functionality
      document
        .getElementById("stop-survey-btn")
        .addEventListener("click", function () {
          if (!window.latestChatRecordId) {
            alert("No chat record available.");
            return;
          }
          // Send a POST request to /stop-survey with the chat record id.
          fetch("/stop-survey", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ record_id: window.latestChatRecordId }),
          })
            .then((response) => response.json())
            .then((data) => {
              if (data.error) {
                alert("Error stopping survey: " + data.error);
              } else {
                // Optionally, show the summary to the user
                alert("Survey stopped");
                // You can also disable further chat input if needed:
                document.getElementById("chat-input").disabled = true;
                document.getElementById("chat-send-btn").disabled = true;
              }
            })
            .catch((err) => {
              alert("Error: " + err);
            });
        });


//         document.getElementById("public-survey-link").addEventListener("click", function(e) {
//   e.preventDefault();
  
//   // Check if survey response and public survey ID have been generated.
//   if (!window.latestRecordId || !window.latestChatRecordId || !window.publicSurveyId) {
//     alert("Please complete the survey before copying the public survey link.");
//     return;
//   }
  
//   // Retrieve the record IDs and public survey id from the global variables.
//   let recordid = window.latestRecordId;
//   let chatrecordid = window.latestChatRecordId;
//   let publicSurveyId = window.publicSurveyId;
  
//   // Construct the public survey URL with the record IDs and public survey id as query parameters.
//   let publicUrl = `${window.location.origin}/public_survey?recordid=${recordid}&chatrecordid=${chatrecordid}&public_survey_id=${publicSurveyId}`;
  
//   // Copy the URL to clipboard using the Clipboard API.
//   navigator.clipboard.writeText(publicUrl)
//     .then(function() {
//       alert("Public survey link copied to clipboard:\n" + publicUrl);
//     })
//     .catch(function(err) {
//       alert("Error copying public survey link: " + err);
//     });
// });
document.getElementById("copy-public-survey-link-btn").addEventListener("click", function(e) {
  e.preventDefault();
  
  console.log("recordid:",window.latestRecordId, "chatRecordId:",window.latestChatRecordId,"publicid:", window.publicSurveyId)
  // Ensure the required parameters are available.
  if (!window.latestRecordId || !window.latestChatRecordId || !window.publicSurveyId) {
    alert("Please complete the survey before copying the public survey link.");
    return;
  }
  
  // Retrieve the IDs from global variables.
  const recordid = window.latestRecordId;
  const chatrecordid = window.latestChatRecordId;
  const publicSurveyId = window.publicSurveyId;
  const surveyHeading = encodeURIComponent(window.currentSurvey.survey_title);
  
  // Construct the public survey URL with query parameters.
  const publicUrl = `${window.location.origin}/public_survey?recordid=${recordid}&chatrecordid=${chatrecordid}&public_survey_id=${publicSurveyId}&heading=${surveyHeading}`;
  
  // Use the Clipboard API to copy the URL.
  navigator.clipboard.writeText(publicUrl)
    .then(function() {
      alert("Public survey link copied to clipboard:\n" + publicUrl);
    })
    .catch(function(err) {
      alert("Error copying public survey link: " + err);
    });
});

async function setupUserAvatarVolumeVisualizer() {
  const userRipple = document.getElementById("user-avatar-ripple");
  if (!userRipple) {
    console.error("User avatar ripple element not found.");
    return;
  }
  
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const analyser = audioContext.createAnalyser();
    const micSource = audioContext.createMediaStreamSource(stream);
    micSource.connect(analyser);
    analyser.fftSize = 256;
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    
    function updateUserRipple() {
  analyser.getByteFrequencyData(dataArray);
  let sum = 0;
  for (let i = 0; i < bufferLength; i++) {
    sum += dataArray[i];
  }
  let avg = sum / bufferLength;
  let volumeLevel = avg / 255; // Normalize volume (0 to 1)
  
  // If volume is very low, set it to 0
  if (volumeLevel < 0.1) {
    volumeLevel = 0;
  }
  
  const scale = 1 + volumeLevel * 3.0; // Adjust multiplier as desired
  const opacity = volumeLevel;         // Opacity from 0 to 1
  userRipple.style.transform = `scale(${scale})`;
  userRipple.style.opacity = opacity;
  
  requestAnimationFrame(updateUserRipple);
}

    updateUserRipple();
  } catch (err) {
    console.error("User mic access error:", err);
    userRipple.style.opacity = 0;
  }
}




    </script>
  </body>
</html>
